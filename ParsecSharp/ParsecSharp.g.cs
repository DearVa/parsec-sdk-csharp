// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace ParsecSharp
{
    /// <summary>Status codes indicating success, warning, or error.</summary>
    /// <remarks>
    /// <para>Returned by most Parsec SDK functions. ::PARSEC_OK is `0`,</para>
    /// <para>warnings are positive, errors are negative.</para>
    /// </remarks>
    public enum Status
    {
        /// <summary>0</summary>
        ParsecOk = 0,
        /// <summary>10</summary>
        WarnContinue = 10,
        /// <summary>4</summary>
        HostWarnShutdown = 4,
        /// <summary>5</summary>
        HostWarnKicked = 5,
        /// <summary>6</summary>
        ConnectWarnApproval = 6,
        /// <summary>8</summary>
        ConnectWarnDeclined = 8,
        /// <summary>9</summary>
        ConnectWarnCanceled = 9,
        /// <summary>99</summary>
        ConnectWarnPeerGone = 99,
        /// <summary>1000</summary>
        DecodeWarnContinue = 1000,
        /// <summary>1001</summary>
        DecodeWarnAccepted = 1001,
        /// <summary>1003</summary>
        DecodeWarnReinit = 1003,
        /// <summary>2000</summary>
        NetworkWarnTimeout = 2000,
        /// <summary>5000</summary>
        QueueWarnEmpty = 5000,
        /// <summary>5001</summary>
        QueueWarnNoBuffer = 5001,
        /// <summary>5003</summary>
        QueueWarnTimeout = 5003,
        /// <summary>6000</summary>
        AudioWarnNoData = 6000,
        /// <summary>-1</summary>
        ErrorDefault = -1,
        /// <summary>-3</summary>
        ParsecNotRunning = -3,
        /// <summary>-4</summary>
        ParsecAlreadyRunning = -4,
        /// <summary>-5</summary>
        ParsecNotImplemented = -5,
        /// <summary>-10</summary>
        DecodeErrorInit = -10,
        /// <summary>-11</summary>
        DecodeErrorLoad = -11,
        /// <summary>-13</summary>
        DecodeErrorMap = -13,
        /// <summary>-14</summary>
        DecodeErrorDecode = -14,
        /// <summary>-15</summary>
        DecodeErrorCleanup = -15,
        /// <summary>-16</summary>
        DecodeErrorParse = -16,
        /// <summary>-17</summary>
        DecodeErrorNoSupport = -17,
        /// <summary>-18</summary>
        DecodeErrorPixelFormat = -18,
        /// <summary>-19</summary>
        DecodeErrorBuffer = -19,
        /// <summary>-20</summary>
        DecodeErrorResolution = -20,
        /// <summary>-6101</summary>
        WebsocketErrorConnect = -6101,
        /// <summary>-3001</summary>
        WebsocketErrorPoll = -3001,
        /// <summary>-3002</summary>
        WebsocketErrorRead = -3002,
        /// <summary>-3003</summary>
        WebsocketErrorWrite = -3003,
        /// <summary>-6105</summary>
        WebsocketErrorClose = -6105,
        /// <summary>-3005</summary>
        WebsocketErrorPing = -3005,
        /// <summary>-3006</summary>
        WebsocketErrorPongTimeout = -3006,
        /// <summary>-3007</summary>
        WebsocketErrorPong = -3007,
        /// <summary>-3008</summary>
        WebsocketErrorAuth = -3008,
        /// <summary>-3009</summary>
        WebsocketErrorGoingAway = -3009,
        /// <summary>-5000</summary>
        ZlibErrorDeflate = -5000,
        /// <summary>-5001</summary>
        ZlibErrorInflate = -5001,
        /// <summary>-6023</summary>
        NatErrorPeerPhase = -6023,
        /// <summary>-6024</summary>
        NatErrorStunPhase = -6024,
        /// <summary>-6033</summary>
        NatErrorNoCandidates = -6033,
        /// <summary>-6111</summary>
        NatErrorJsonAction = -6111,
        /// <summary>-6112</summary>
        NatErrorNoSocket = -6112,
        /// <summary>-7000</summary>
        OpenGlErrorContext = -7000,
        /// <summary>-7001</summary>
        OpenGlErrorShare = -7001,
        /// <summary>-7002</summary>
        OpenGlErrorPixformat = -7002,
        /// <summary>-7003</summary>
        OpenGlErrorCurrent = -7003,
        /// <summary>-7004</summary>
        OpenGlErrorDc = -7004,
        /// <summary>-7005</summary>
        OpenGlErrorShader = -7005,
        /// <summary>-7006</summary>
        OpenGlErrorProgram = -7006,
        /// <summary>-7007</summary>
        OpenGlErrorVersion = -7007,
        /// <summary>-7008</summary>
        OpenGlErrorTexture = -7008,
        /// <summary>-8000</summary>
        JsonErrorParse = -8000,
        /// <summary>-8001</summary>
        JsonErrorMissing = -8001,
        /// <summary>-8002</summary>
        JsonErrorType = -8002,
        /// <summary>-8003</summary>
        JsonErrorValType = -8003,
        /// <summary>-8004</summary>
        JsonErrorBuffer = -8004,
        /// <summary>-8005</summary>
        JsonErrorFopen = -8005,
        /// <summary>-8006</summary>
        JsonErrorFread = -8006,
        /// <summary>-8007</summary>
        JsonErrorFwrite = -8007,
        /// <summary>-9000</summary>
        AudioErrorInit = -9000,
        /// <summary>-9001</summary>
        AudioErrorCapture = -9001,
        /// <summary>-9002</summary>
        AudioErrorNetwork = -9002,
        /// <summary>-9003</summary>
        AudioErrorFree = -9003,
        /// <summary>-9004</summary>
        AudioErrorPlay = -9004,
        /// <summary>-10000</summary>
        AudioOpusErrorInit = -10000,
        /// <summary>-10001</summary>
        AudioOpusErrorDecode = -10001,
        /// <summary>-10002</summary>
        AudioOpusErrorEncode = -10002,
        /// <summary>-12007</summary>
        NetworkErrorBgTimeout = -12007,
        /// <summary>-12008</summary>
        NetworkErrorBadPacket = -12008,
        /// <summary>-12011</summary>
        NetworkErrorBuffer = -12011,
        /// <summary>-12017</summary>
        NetworkErrorShutdown = -12017,
        /// <summary>-12018</summary>
        NetworkErrorUnsupported = -12018,
        /// <summary>-12019</summary>
        NetworkErrorInterrupted = -12019,
        /// <summary>-13000</summary>
        ServerErrorDisplay = -13000,
        /// <summary>-13008</summary>
        ServerErrorResolution = -13008,
        /// <summary>-13009</summary>
        ServerErrorMaxResolution = -13009,
        /// <summary>-13011</summary>
        ServerErrorNoUser = -13011,
        /// <summary>-13012</summary>
        ServerErrorNoRoom = -13012,
        /// <summary>-13013</summary>
        ServerErrorVideoDone = -13013,
        /// <summary>-13014</summary>
        ServerErrorClientAbort = -13014,
        /// <summary>-13015</summary>
        ServerErrorClientGone = -13015,
        /// <summary>-14003</summary>
        CaptureErrorInit = -14003,
        /// <summary>-14004</summary>
        CaptureErrorTexture = -14004,
        /// <summary>-15000</summary>
        EncodeErrorInit = -15000,
        /// <summary>-15002</summary>
        EncodeErrorEncode = -15002,
        /// <summary>-15006</summary>
        EncodeErrorBuffer = -15006,
        /// <summary>-15100</summary>
        EncodeErrorProperties = -15100,
        /// <summary>-15101</summary>
        EncodeErrorLibrary = -15101,
        /// <summary>-15007</summary>
        EncodeErrorSession = -15007,
        /// <summary>-15103</summary>
        EncodeErrorSession1 = -15103,
        /// <summary>-15104</summary>
        EncodeErrorSession2 = -15104,
        /// <summary>-15105</summary>
        EncodeErrorOutputInit = -15105,
        /// <summary>-15106</summary>
        EncodeErrorTexture = -15106,
        /// <summary>-15107</summary>
        EncodeErrorOutput = -15107,
        /// <summary>-15108</summary>
        EncodeErrorUnsupported = -15108,
        /// <summary>-15109</summary>
        EncodeErrorHandle = -15109,
        /// <summary>-15110</summary>
        EncodeErrorCaps = -15110,
        /// <summary>-19000</summary>
        UpnpError = -19000,
        /// <summary>-22000</summary>
        D3dErrorTexture = -22000,
        /// <summary>-22001</summary>
        D3dErrorShader = -22001,
        /// <summary>-22002</summary>
        D3dErrorBuffer = -22002,
        /// <summary>-22003</summary>
        D3dErrorLayout = -22003,
        /// <summary>-22004</summary>
        D3dErrorDevice = -22004,
        /// <summary>-22005</summary>
        D3dErrorMt = -22005,
        /// <summary>-22006</summary>
        D3dErrorAdapter = -22006,
        /// <summary>-22007</summary>
        D3dErrorFactory = -22007,
        /// <summary>-22008</summary>
        D3dErrorOutput = -22008,
        /// <summary>-22009</summary>
        D3dErrorContext = -22009,
        /// <summary>-22010</summary>
        D3dErrorOutput1 = -22010,
        /// <summary>-22011</summary>
        D3dErrorSwapChain = -22011,
        /// <summary>-22012</summary>
        D3dErrorDraw = -22012,
        /// <summary>-22013</summary>
        D3dErrorOutput5 = -22013,
        /// <summary>-23000</summary>
        H26xErrorNotFound = -23000,
        /// <summary>-28000</summary>
        AesGcmErrorKeyLen = -28000,
        /// <summary>-28001</summary>
        AesGcmErrorEncrypt = -28001,
        /// <summary>-28002</summary>
        AesGcmErrorDecrypt = -28002,
        /// <summary>-28003</summary>
        AesGcmErrorCtx = -28003,
        /// <summary>-28004</summary>
        AesGcmErrorBuffer = -28004,
        /// <summary>-28005</summary>
        AesGcmErrorOverflow = -28005,
        /// <summary>-32000</summary>
        SctpErrorGlobalInit = -32000,
        /// <summary>-32001</summary>
        SctpErrorWrite = -32001,
        /// <summary>-32002</summary>
        SctpErrorSocket = -32002,
        /// <summary>-32003</summary>
        SctpErrorBind = -32003,
        /// <summary>-32004</summary>
        SctpErrorConnect = -32004,
        /// <summary>-33000</summary>
        DtlsErrorBioWrite = -33000,
        /// <summary>-33001</summary>
        DtlsErrorBioRead = -33001,
        /// <summary>-33002</summary>
        DtlsErrorSsl = -33002,
        /// <summary>-33003</summary>
        DtlsErrorBuffer = -33003,
        /// <summary>-33004</summary>
        DtlsErrorNoData = -33004,
        /// <summary>-33005</summary>
        DtlsErrorCert = -33005,
        /// <summary>-34000</summary>
        StunErrorPacket = -34000,
        /// <summary>-34001</summary>
        StunErrorParseHeader = -34001,
        /// <summary>-34002</summary>
        StunErrorParseAddress = -34002,
        /// <summary>-35000</summary>
        SoErrorOpen = -35000,
        /// <summary>-35001</summary>
        SoErrorSymbol = -35001,
        /// <summary>-36000</summary>
        ParsecErrorVersion = -36000,
        /// <summary>-36001</summary>
        ParsecErrorVerData = -36001,
        /// <summary>-37000</summary>
        ResampleErrorInit = -37000,
        /// <summary>-37001</summary>
        ResampleErrorResample = -37001,
        /// <summary>Caused when the graphics render engine isn't supported in Unity.</summary>
        UnityUnsupportedEngine = -38000,
        /// <summary>`SSL_get_error` value will be subtracted from this value.</summary>
        OpensslError = -600000,
        /// <summary>`WSAGetLastError` value will be subtracted from this value.</summary>
        SocketError = -700000,
    }

    /// <summary>Log level.</summary>
    /// <remarks>Passed through ::ParsecLogCallback set with ::ParsecSetLogCallback.</remarks>
    public enum LogLevel
    {
        /// <summary>Messages interesting to support staff trying to figure out the context of an issue.</summary>
        Info = 105,
        /// <summary>Messages interesting to developers trying to debug an issue.</summary>
        Debug = 100,
    }

    /// <summary>Keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage.</remarks>
    public enum Keycode
    {
        /// <summary>4</summary>
        A = 4,
        /// <summary>5</summary>
        B = 5,
        /// <summary>6</summary>
        C = 6,
        /// <summary>7</summary>
        D = 7,
        /// <summary>8</summary>
        E = 8,
        /// <summary>9</summary>
        F = 9,
        /// <summary>10</summary>
        G = 10,
        /// <summary>11</summary>
        H = 11,
        /// <summary>12</summary>
        I = 12,
        /// <summary>13</summary>
        J = 13,
        /// <summary>14</summary>
        K = 14,
        /// <summary>15</summary>
        L = 15,
        /// <summary>16</summary>
        M = 16,
        /// <summary>17</summary>
        N = 17,
        /// <summary>18</summary>
        O = 18,
        /// <summary>19</summary>
        P = 19,
        /// <summary>20</summary>
        Q = 20,
        /// <summary>21</summary>
        R = 21,
        /// <summary>22</summary>
        S = 22,
        /// <summary>23</summary>
        T = 23,
        /// <summary>24</summary>
        U = 24,
        /// <summary>25</summary>
        V = 25,
        /// <summary>26</summary>
        W = 26,
        /// <summary>27</summary>
        X = 27,
        /// <summary>28</summary>
        Y = 28,
        /// <summary>29</summary>
        Z = 29,
        /// <summary>30</summary>
        Digital1 = 30,
        /// <summary>31</summary>
        Digital2 = 31,
        /// <summary>32</summary>
        Digital3 = 32,
        /// <summary>33</summary>
        Digital4 = 33,
        /// <summary>34</summary>
        Digital5 = 34,
        /// <summary>35</summary>
        Digital6 = 35,
        /// <summary>36</summary>
        Digital7 = 36,
        /// <summary>37</summary>
        Digital8 = 37,
        /// <summary>38</summary>
        Digital9 = 38,
        /// <summary>39</summary>
        Digital0 = 39,
        /// <summary>40</summary>
        Enter = 40,
        /// <summary>41</summary>
        Escape = 41,
        /// <summary>42</summary>
        Backspace = 42,
        /// <summary>43</summary>
        Tab = 43,
        /// <summary>44</summary>
        Space = 44,
        /// <summary>45</summary>
        Minus = 45,
        /// <summary>46</summary>
        Equals = 46,
        /// <summary>47</summary>
        LeftBracket = 47,
        /// <summary>48</summary>
        RightBracket = 48,
        /// <summary>49</summary>
        Backslash = 49,
        /// <summary>51</summary>
        Semicolon = 51,
        /// <summary>52</summary>
        Apostrophe = 52,
        /// <summary>53</summary>
        Backtick = 53,
        /// <summary>54</summary>
        Comma = 54,
        /// <summary>55</summary>
        Period = 55,
        /// <summary>56</summary>
        Slash = 56,
        /// <summary>57</summary>
        CapsLock = 57,
        /// <summary>58</summary>
        F1 = 58,
        /// <summary>59</summary>
        F2 = 59,
        /// <summary>60</summary>
        F3 = 60,
        /// <summary>61</summary>
        F4 = 61,
        /// <summary>62</summary>
        F5 = 62,
        /// <summary>63</summary>
        F6 = 63,
        /// <summary>64</summary>
        F7 = 64,
        /// <summary>65</summary>
        F8 = 65,
        /// <summary>66</summary>
        F9 = 66,
        /// <summary>67</summary>
        F10 = 67,
        /// <summary>68</summary>
        F11 = 68,
        /// <summary>69</summary>
        F12 = 69,
        /// <summary>70</summary>
        PrintScreen = 70,
        /// <summary>71</summary>
        ScrollLock = 71,
        /// <summary>72</summary>
        Pause = 72,
        /// <summary>73</summary>
        Insert = 73,
        /// <summary>74</summary>
        Home = 74,
        /// <summary>75</summary>
        PageUp = 75,
        /// <summary>76</summary>
        Delete = 76,
        /// <summary>77</summary>
        End = 77,
        /// <summary>78</summary>
        PageDown = 78,
        /// <summary>79</summary>
        Right = 79,
        /// <summary>80</summary>
        Left = 80,
        /// <summary>81</summary>
        Down = 81,
        /// <summary>82</summary>
        Up = 82,
        /// <summary>83</summary>
        NumLock = 83,
        /// <summary>84</summary>
        NumPadDivide = 84,
        /// <summary>85</summary>
        NumPadMultiply = 85,
        /// <summary>86</summary>
        NumPadMinus = 86,
        /// <summary>87</summary>
        NumPadPlus = 87,
        /// <summary>88</summary>
        NumPadEnter = 88,
        /// <summary>89</summary>
        NumPad1 = 89,
        /// <summary>90</summary>
        NumPad2 = 90,
        /// <summary>91</summary>
        NumPad3 = 91,
        /// <summary>92</summary>
        NumPad4 = 92,
        /// <summary>93</summary>
        NumPad5 = 93,
        /// <summary>94</summary>
        NumPad6 = 94,
        /// <summary>95</summary>
        NumPad7 = 95,
        /// <summary>96</summary>
        NumPad8 = 96,
        /// <summary>97</summary>
        NumPad9 = 97,
        /// <summary>98</summary>
        NumPad0 = 98,
        /// <summary>99</summary>
        NumPadPeriod = 99,
        /// <summary>101</summary>
        Application = 101,
        /// <summary>104</summary>
        F13 = 104,
        /// <summary>105</summary>
        F14 = 105,
        /// <summary>106</summary>
        F15 = 106,
        /// <summary>107</summary>
        F16 = 107,
        /// <summary>108</summary>
        F17 = 108,
        /// <summary>109</summary>
        F18 = 109,
        /// <summary>110</summary>
        F19 = 110,
        /// <summary>118</summary>
        Menu = 118,
        /// <summary>127</summary>
        Mute = 127,
        /// <summary>128</summary>
        VolumeUp = 128,
        /// <summary>129</summary>
        VolumeDown = 129,
        /// <summary>224</summary>
        LeftCtrl = 224,
        /// <summary>225</summary>
        LeftShift = 225,
        /// <summary>226</summary>
        LeftAlt = 226,
        /// <summary>227</summary>
        LeftGui = 227,
        /// <summary>228</summary>
        RightCtrl = 228,
        /// <summary>229</summary>
        RightShift = 229,
        /// <summary>230</summary>
        RightAlt = 230,
        /// <summary>231</summary>
        RightGui = 231,
        /// <summary>258</summary>
        AudioNext = 258,
        /// <summary>259</summary>
        AudioPrevious = 259,
        /// <summary>260</summary>
        AudioStop = 260,
        /// <summary>261</summary>
        AudioPlay = 261,
        /// <summary>262</summary>
        AudioMute = 262,
        /// <summary>263</summary>
        MediaSelect = 263,
    }

    /// <summary>Stateful modifier keys applied to keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage. These values may be bitwise OR'd together.</remarks>
    public enum Keymod
    {
        /// <summary>No stateful modifier key active.</summary>
        None = 0,
        /// <summary>`NUMLOCK` is currently active.</summary>
        Num = 4096,
        /// <summary>`CAPSLOCK` is currently active.</summary>
        Caps = 8192,
    }

    /// <summary>Mouse button.</summary>
    /// <remarks>Member of ::ParsecMouseButtonMessage.</remarks>
    public enum MouseButton
    {
        /// <summary>Left mouse button.</summary>
        L = 1,
        /// <summary>Middle mouse button.</summary>
        Middle = 2,
        /// <summary>Right mouse button.</summary>
        R = 3,
        /// <summary>Extra mouse button 1.</summary>
        X1 = 4,
        /// <summary>Extra mouse button 2.</summary>
        X2 = 5,
    }

    /// <summary>Gamepad button.</summary>
    /// <remarks>Member of ::ParsecGamepadButtonMessage.</remarks>
    public enum GamepadButton
    {
        /// <summary>A button.</summary>
        A = 0,
        /// <summary>B button.</summary>
        B = 1,
        /// <summary>X button.</summary>
        X = 2,
        /// <summary>Y button.</summary>
        Y = 3,
        /// <summary>Back button.</summary>
        Back = 4,
        /// <summary>Guide button.</summary>
        Guide = 5,
        /// <summary>Start button.</summary>
        Start = 6,
        /// <summary>Left thumbstick button.</summary>
        LeftStick = 7,
        /// <summary>Right thumbstick button.</summary>
        RightStick = 8,
        /// <summary>Left shoulder (bumper) button.</summary>
        LeftShoulder = 9,
        /// <summary>Right shoulder (bumper) button.</summary>
        RightShoulder = 10,
        /// <summary>Analog DPAD up.</summary>
        DpadUp = 11,
        /// <summary>Analog DPAD down.</summary>
        DpadDown = 12,
        /// <summary>Analog DPAD left.</summary>
        DpadLeft = 13,
        /// <summary>Analog DPAD right.</summary>
        DpadRight = 14,
    }

    /// <summary>Gamepad axes related to thumbsticks and triggers.</summary>
    /// <remarks>Member of ::ParsecGamepadAxisMessage.</remarks>
    public enum GamepadAxis
    {
        /// <summary>Gamepad left thumbstick x-axis.</summary>
        LeftX = 0,
        /// <summary>Gamepad left thumbstick y-axis.</summary>
        LeftY = 1,
        /// <summary>Gamepad right thumbstick x-axis.</summary>
        RightX = 2,
        /// <summary>Gamepad right thumbstick y-axis.</summary>
        RightY = 3,
        /// <summary>Gamepad left trigger value.</summary>
        LeftTrigger = 4,
        /// <summary>Gamepad right trigger value.</summary>
        RightTrigger = 5,
    }

    /// <summary>Input message type.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public enum MessageType
    {
        /// <summary>`keyboard` ::ParsecKeyboardMessage is valid in ::ParsecMessage.</summary>
        Keyboard = 1,
        /// <summary>`mouseButton` ::ParsecMouseButtonMessage is valid in ::ParsecMessage.</summary>
        MouseButton = 2,
        /// <summary>`mouseWheel` ::ParsecMouseWheelMessage is valid in ::ParsecMessage.</summary>
        MouseWheel = 3,
        /// <summary>`mouseMotion` ::ParsecMouseMotionMessage is valid in ::ParsecMessage.</summary>
        MouseMotion = 4,
        /// <summary>`gamepadButton` ::ParsecGamepadButtonMessage is valid in ::ParsecMessage.</summary>
        GamepadButton = 5,
        /// <summary>`gamepadAxis` ::ParsecGamepadAxisMessage is valid in ::ParsecMessage.</summary>
        GamepadAxis = 6,
        /// <summary>`gamepadUnplug` ::ParsecGamepadUnplugMessage is valid in ::ParsecMessage.</summary>
        GamepadUnplug = 7,
    }

    /// <summary>Color formats for raw image data.</summary>
    /// <remarks>Member of ::ParsecFrame.</remarks>
    public enum ColorFormat
    {
        Unknown = 0,
        /// <summary>4:2:0 full width/height Y plane followed by an interleaved half width/height UV plane.</summary>
        Nv12 = 1,
        /// <summary>4:2:0 full width/height Y plane followed by a half width/height U plane followed by a half width/height V plane.</summary>
        I420 = 2,
        /// <summary>4:2:2 full width/height Y plane followed by an interleaved half width full height UV plane.</summary>
        Nv16 = 3,
        /// <summary>4:2:2 full width/height Y plane followed by a half width full height U plane followed by a half width full height V plane.</summary>
        I422 = 4,
        /// <summary>32-bits per pixel, 8-bits per channel BGRA.</summary>
        Bgra = 5,
        /// <summary>32-bits per pixel, 8-bits per channel RGBA.</summary>
        Rgba = 6,
    }

    /// <summary>Network protocol used for peer-to-peer connections.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    public enum Protocol
    {
        /// <summary>Parsec's low-latency optimized BUD protocol.</summary>
        Bud = 1,
        /// <summary>SCTP protocol compatible with WebRTC data channels.</summary>
        Sctp = 2,
    }

    /// <summary>Video stream container.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    public enum Container
    {
        /// <summary>Parsec's custom container compatible with native decoding.</summary>
        Parsec = 0,
        /// <summary>MP4 box container compatible with web browser Media Source Extensions.</summary>
        Mp4 = 2,
    }

    /// <summary>PCM audio format.</summary>
    /// <remarks>Passed to ::ParsecHostSubmitAudio.</remarks>
    public enum PCMFormat
    {
        /// <summary>32-bit floating point samples.</summary>
        Float = 1,
        /// <summary>16-bit signed integer samples.</summary>
        Int16 = 2,
    }

    /// <summary>Guest connection lifecycle states.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostGetGuests.</remarks>
    [Flags]
    public enum GuestState
    {
        /// <summary>The guest is currently waiting for the host to allow them via ::ParsecHostAllowGuest. ::HOST_DESKTOP only.</summary>
        Waiting = 1,
        /// <summary>The guest is attempting to make a peer-to-peer connection to the host.</summary>
        Connecting = 2,
        /// <summary>The guest successfully connected.</summary>
        Connected = 4,
        /// <summary>The guest disconnected.</summary>
        Disconnected = 8,
        /// <summary>The guest failed peer-to-peer negotiation.</summary>
        Failed = 16,
    }

    /// <summary>Host mode of operation.</summary>
    /// <remarks>Passed to ::ParsecHostStart.</remarks>
    public enum HostMode
    {
        /// <summary>The host intends to share their entire desktop. Permission and approval systems apply. Windows only.</summary>
        Desktop = 1,
        /// <summary>Parsec is integrated into a game. The game uses the `Submit` model to provide output.</summary>
        Game = 2,
    }

    /// <summary>Host event type.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    public enum HostEventType
    {
        /// <summary>A guest has changed connection state, `guestStateChange` is valid in ::ParsecHostEvent.</summary>
        GuestStateChange = 1,
        /// <summary>User-defined message from a guest, `userData is valid in ::ParsecHostEvent.</summary>
        UserData = 2,
        /// <summary>The host's Session ID has become invalid.</summary>
        InvalidSessionId = 4,
    }

    /// <summary>Client event type.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public enum ClientEventType
    {
        /// <summary>A cursor mode change or image update is available, `cursor` is valid in ::ParsecClientEvent. Call ::ParsecGetBuffer in the case of an image update.</summary>
        Cursor = 1,
        /// <summary>Gamepad rumble event, `rumble` is valid in ::ParsecClientEvent.</summary>
        Rumble = 2,
        /// <summary>User-defined message from the host, `userData` is valid in ::ParsecClientEvent.</summary>
        UserData = 3,
        /// <summary>The client has been temporarily blocked from sending input and receiving host output.</summary>
        Blocked = 4,
        /// <summary>The client has returned to normal operation after receiving a ::CLIENT_EVENT_BLOCKED.</summary>
        Unblocked = 5,
    }

    /// <summary>Status codes indicating success, warning, or error.</summary>
    /// <remarks>
    /// <para>Returned by most Parsec SDK functions. ::PARSEC_OK is `0`,</para>
    /// <para>warnings are positive, errors are negative.</para>
    /// </remarks>
    /// <summary>Log level.</summary>
    /// <remarks>Passed through ::ParsecLogCallback set with ::ParsecSetLogCallback.</remarks>
    /// <summary>Keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage.</remarks>
    /// <summary>Stateful modifier keys applied to keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage. These values may be bitwise OR'd together.</remarks>
    /// <summary>Mouse button.</summary>
    /// <remarks>Member of ::ParsecMouseButtonMessage.</remarks>
    /// <summary>Gamepad button.</summary>
    /// <remarks>Member of ::ParsecGamepadButtonMessage.</remarks>
    /// <summary>Gamepad axes related to thumbsticks and triggers.</summary>
    /// <remarks>Member of ::ParsecGamepadAxisMessage.</remarks>
    /// <summary>Input message type.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Color formats for raw image data.</summary>
    /// <remarks>Member of ::ParsecFrame.</remarks>
    /// <summary>Network protocol used for peer-to-peer connections.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    /// <summary>Video stream container.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    /// <summary>PCM audio format.</summary>
    /// <remarks>Passed to ::ParsecHostSubmitAudio.</remarks>
    /// <summary>Guest connection lifecycle states.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostGetGuests.</remarks>
    /// <summary>Host mode of operation.</summary>
    /// <remarks>Passed to ::ParsecHostStart.</remarks>
    /// <summary>Host event type.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    /// <summary>Client event type.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>::Parsec instance configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecInit and returned by ::ParsecGetConfig. `clientPort` and `hostPort`</para>
    /// <para>serve as the first port used when the `bind` call is made internally. If the port is already in use,</para>
    /// <para>the next port will be tried until an open port has been found or 50 attempts have been made.</para>
    /// </remarks>
    /// <summary>Video frame properties.</summary>
    /// <remarks>Passed through ::ParsecFrameCallback after calling ::ParsecClientPollFrame.</remarks>
    /// <summary>Cursor properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecClientCursorEvent, which is itself a member of ::ParsecClientEvent,</para>
    /// <para>returned by ::ParsecClientPollEvents. Also passed to ::ParsecHostSubmitCursor to update the cursor while</para>
    /// <para>in ::HOST_GAME. When polled from ::ParsecClientPollEvents, `positionX` and `positionY` are</para>
    /// <para>affected by the values set via ::ParsecClientSetDimensions.</para>
    /// </remarks>
    /// <summary>Guest input permissions.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostSetPermissions. Only relevant in ::HOST_DESKTOP.</remarks>
    /// <summary>Latency performance metrics.</summary>
    /// <remarks>Member of ::ParsecGuest and ::ParsecClientStatus.</remarks>
    /// <summary>Guest properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecGuestStateChangeEvent and ::ParsecUserDataEvent. Returned by ::ParsecHostGetGuests</para>
    /// <para>and ::ParsecHostPollInput.</para>
    /// </remarks>
    /// <summary>Keyboard message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Mouse button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Mouse wheel message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Mouse motion message.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecMessage. Mouse motion can be sent in either relative or absolute mode via</para>
    /// <para>the `relative` member. Absolute mode treats the `x` and `y` values as the exact destination for where</para>
    /// <para>the cursor will appear. These values are sent from the client in device screen coordinates and are translated</para>
    /// <para>in accordance with the values set via ::ParsecClientSetDimensions. Relative mode `x` and `y` values are not</para>
    /// <para>affected by ::ParsecClientSetDimensions and move the cursor with a signed delta value from its previous location.</para>
    /// </remarks>
    /// <summary>Gamepad button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Gamepad axis message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Gamepad unplug message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Generic input message that can represent any message type.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientSendMessage or returned by ::ParsecHostPollInput while</para>
    /// <para>in ::HOST_GAME. The application can switch on the `type` member to see which `Message`</para>
    /// <para>struct should be evaluated. The `Message` structs are unioned.</para>
    /// </remarks>
    /// <summary>Client configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientConnect. Regarding `resolutionX`, `resolutionY`, and `refreshRate`:</para>
    /// <para>These settings apply only in ::HOST_DESKTOP if the client is the first client to connect, and that client is</para>
    /// <para>the owner of the computer. Setting `resolutionX` or `resolutionY` to `0` will leave the host resolution unaffected,</para>
    /// <para>otherwise the host will attempt to find the closest matching resolution / refresh rate.</para>
    /// </remarks>
    /// <summary>Client connection health and status information.</summary>
    /// <remarks>Returned by ::ParsecClientGetStatus.</remarks>
    /// <summary>Cursor mode/image update event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>Gamepad rumble data event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>User-defined host message event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>Generic client event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecClientPollEvents. The application can switch on the `type` member to see</para>
    /// <para>which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    /// <summary>Host configuration.</summary>
    /// <remarks>Member of ::ParsecHostStatus, passed to ::ParsecHostStart and ::ParsecHostSetConfig.</remarks>
    /// <summary>Host runtime status.</summary>
    /// <remarks>Returned by ::ParsecHostGetStatus.</remarks>
    /// <summary>Guest connection state change event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    /// <summary>User-defined guest message event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    /// <summary>Generic host event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecHostPollEvents. The application can switch on the `type` member</para>
    /// <para>to see which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    /// <summary>OpenGL/GLES 32-bit unsigned integer.</summary>
    /// <remarks>Passed to ::ParsecHostGLSubmitFrame. Prevents obligatory include of GL headers.</remarks>
    /// <summary>D3D11 `ID3D11Device`.</summary>
    /// <remarks>Passed to ::ParsecHostD3D11SubmitFrame. Prevents obligatory include of d3d11.h.</remarks>
    /// <summary>D3D11 `ID3D11DeviceContext`.</summary>
    /// <remarks>Passed to ::ParsecHostD3D11SubmitFrame. Prevents obligatory include of d3d11.h.</remarks>
    /// <summary>D3D11 `ID3D11Texture2D`.</summary>
    /// <remarks>Passed to ::ParsecHostD3D11SubmitFrame. Prevents obligatory include of d3d11.h.</remarks>
    /// <summary>Fired when a new log message is available from the Parsec SDK.</summary>
    /// <param name="level">::ParsecLogLevel level value.</param>
    /// <param name="msg">Null-terminated UTF-8 string containing the full log message.</param>
    /// <param name="opaque">User supplied context passed to ::ParsecSetLogCallback.</param>
    /// <remarks>Passed to ::ParsecSetLogCallback.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LogCallback(global::ParsecSharp.LogLevel level, sbyte* msg, __IntPtr opaque);

    /// <summary>Fired synchronously if a new frame is available from the host.</summary>
    /// <param name="frame">Video frame properties.</param>
    /// <param name="image">The video frame buffer containing image data.</param>
    /// <param name="opaque">User supplied context passed to ::ParsecClientPollFrame.</param>
    /// <remarks>Passed to ::ParsecClientPollFrame.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void FrameCallback(__IntPtr frame, byte* image, __IntPtr opaque);

    /// <summary>Fired synchronously if new audio is available from the host.</summary>
    /// <param name="pcm">16-bit signed, two channel, 48KHz PCM audio samples.</param>
    /// <param name="frames">Number of audio frames.</param>
    /// <param name="opaque">User supplied context passed to ::ParsecClientPollAudio.</param>
    /// <remarks>Passed to ::ParsecClientPollAudio.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void AudioCallback(short* pcm, uint frames, __IntPtr opaque);

    /// <summary>::Parsec instance configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecInit and returned by ::ParsecGetConfig. `clientPort` and `hostPort`</para>
    /// <para>serve as the first port used when the `bind` call is made internally. If the port is already in use,</para>
    /// <para>the next port will be tried until an open port has been found or 50 attempts have been made.</para>
    /// </remarks>
    public unsafe partial struct Config
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int upnp;
            internal int clientPort;
            internal int hostPort;
        }

        private Config.__Internal __instance;
        internal Config.__Internal __Instance => __instance;

        internal static Config __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Config(native.ToPointer(), skipVTables);
        }

        internal static Config __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Config(native, skipVTables);
        }

        private Config(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Config(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Config.__Internal*) native;
        }

        /// <summary>`1` enables and maintains UPnP to assist NAT traversal, `0` disables it.</summary>
        public int Upnp
        {
            get
            {
                return __instance.upnp;
            }

            set
            {
                __instance.upnp = value;
            }
        }

        /// <summary>First port tried for client connections. A value of `0` uses a pseudo random default.</summary>
        public int ClientPort
        {
            get
            {
                return __instance.clientPort;
            }

            set
            {
                __instance.clientPort = value;
            }
        }

        /// <summary>First port used to accept host connections. A value of `0` uses a pseudo random default.</summary>
        public int HostPort
        {
            get
            {
                return __instance.hostPort;
            }

            set
            {
                __instance.hostPort = value;
            }
        }
    }

    public unsafe partial class Parsec
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecDestroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Destroy(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecGetConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetConfig(__IntPtr __instance, __IntPtr cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecGetBuffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetBuffer(__IntPtr __instance, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientConnect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientConnect(__IntPtr __instance, __IntPtr cfg, sbyte* sessionID, sbyte* peerID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientDisconnect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClientDisconnect(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientGetStatus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientGetStatus(__IntPtr __instance, __IntPtr status);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientSetDimensions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientSetDimensions(__IntPtr __instance, uint width, uint height, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientPollFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientPollFrame(__IntPtr __instance, __IntPtr callback, uint timeout, __IntPtr opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientPollAudio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientPollAudio(__IntPtr __instance, __IntPtr callback, uint timeout, __IntPtr opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientPollEvents", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ClientPollEvents(__IntPtr __instance, uint timeout, __IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientGLRenderFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientGLRenderFrame(__IntPtr __instance, uint timeout);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientGLDestroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClientGLDestroy(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientSendMessage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientSendMessage(__IntPtr __instance, __IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientSendUserData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientSendUserData(__IntPtr __instance, uint id, sbyte* text);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostStart", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostStart(__IntPtr __instance, global::ParsecSharp.HostMode mode, __IntPtr cfg, sbyte* sessionID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostStop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HostStop(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostGetStatus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HostGetStatus(__IntPtr __instance, __IntPtr status);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSetConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSetConfig(__IntPtr __instance, __IntPtr cfg, sbyte* sessionID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostGetGuests", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint HostGetGuests(__IntPtr __instance, global::ParsecSharp.GuestState state, __IntPtr guests);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostKickGuest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostKickGuest(__IntPtr __instance, uint guestID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSendUserData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSendUserData(__IntPtr __instance, uint guestID, uint id, sbyte* text);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostPollEvents", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HostPollEvents(__IntPtr __instance, uint timeout, __IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostAllowGuest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostAllowGuest(__IntPtr __instance, sbyte* attemptID, bool allow);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSetPermissions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSetPermissions(__IntPtr __instance, uint guestID, __IntPtr perms);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostPollInput", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HostPollInput(__IntPtr __instance, uint timeout, __IntPtr guest, __IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSubmitAudio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSubmitAudio(__IntPtr __instance, global::ParsecSharp.PCMFormat format, uint sampleRate, byte* pcm, uint frames);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSubmitCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSubmitCursor(__IntPtr __instance, __IntPtr cursor, byte* image);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSubmitRumble", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSubmitRumble(__IntPtr __instance, uint guestID, uint gamepadID, byte motorBig, byte motorSmall);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostGLSubmitFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostGLSubmitFrame(__IntPtr __instance, uint frame);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostD3D11SubmitFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostD3D11SubmitFrame(__IntPtr __instance, __IntPtr device, __IntPtr context, __IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecInit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status Init(uint ver, __IntPtr cfg, __IntPtr reserved, __IntPtr ps);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Free(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecSetLogCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetLogCallback(__IntPtr callback, __IntPtr opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint Version();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Parsec> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Parsec>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Parsec managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Parsec managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Parsec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Parsec(native.ToPointer(), skipVTables);
        }

        internal static Parsec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Parsec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Parsec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Parsec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Parsec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Parsec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        internal void Destroy()
        {
            __Internal.Destroy(__Instance);
        }

        public void GetConfig(global::ParsecSharp.Config cfg)
        {
            var ____arg0 = cfg.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            __Internal.GetConfig(__Instance, __arg0);
        }

        public __IntPtr GetBuffer(uint key)
        {
            var ___ret = __Internal.GetBuffer(__Instance, key);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientConnect(global::ParsecSharp.ClientConfig cfg, sbyte* sessionID, sbyte* peerID)
        {
            var ____arg0 = cfg.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.ClientConnect(__Instance, __arg0, sessionID, peerID);
            return ___ret;
        }

        public void ClientDisconnect()
        {
            __Internal.ClientDisconnect(__Instance);
        }

        public global::ParsecSharp.Status ClientGetStatus(global::ParsecSharp.ClientStatus status)
        {
            var ____arg0 = status.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.ClientGetStatus(__Instance, __arg0);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientSetDimensions(uint width, uint height, float scale)
        {
            var ___ret = __Internal.ClientSetDimensions(__Instance, width, height, scale);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientPollFrame(global::ParsecSharp.FrameCallback callback, uint timeout, __IntPtr opaque)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.ClientPollFrame(__Instance, __arg0, timeout, opaque);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientPollAudio(global::ParsecSharp.AudioCallback callback, uint timeout, __IntPtr opaque)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.ClientPollAudio(__Instance, __arg0, timeout, opaque);
            return ___ret;
        }

        public bool ClientPollEvents(uint timeout, global::ParsecSharp.ClientEvent @event)
        {
            var ____arg1 = @event.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.ClientPollEvents(__Instance, timeout, __arg1);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientGLRenderFrame(uint timeout)
        {
            var ___ret = __Internal.ClientGLRenderFrame(__Instance, timeout);
            return ___ret;
        }

        public void ClientGLDestroy()
        {
            __Internal.ClientGLDestroy(__Instance);
        }

        public global::ParsecSharp.Status ClientSendMessage(global::ParsecSharp.Message msg)
        {
            var ____arg0 = msg.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.ClientSendMessage(__Instance, __arg0);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientSendUserData(uint id, sbyte* text)
        {
            var ___ret = __Internal.ClientSendUserData(__Instance, id, text);
            return ___ret;
        }

        public global::ParsecSharp.Status HostStart(global::ParsecSharp.HostMode mode, global::ParsecSharp.HostConfig cfg, sbyte* sessionID)
        {
            var ____arg1 = cfg.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.HostStart(__Instance, mode, __arg1, sessionID);
            return ___ret;
        }

        public void HostStop()
        {
            __Internal.HostStop(__Instance);
        }

        public void HostGetStatus(global::ParsecSharp.HostStatus status)
        {
            var ____arg0 = status.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            __Internal.HostGetStatus(__Instance, __arg0);
        }

        public global::ParsecSharp.Status HostSetConfig(global::ParsecSharp.HostConfig cfg, sbyte* sessionID)
        {
            var ____arg0 = cfg.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.HostSetConfig(__Instance, __arg0, sessionID);
            return ___ret;
        }

        public uint HostGetGuests(global::ParsecSharp.GuestState state, __IntPtr guests)
        {
            var ___ret = __Internal.HostGetGuests(__Instance, state, guests);
            return ___ret;
        }

        public global::ParsecSharp.Status HostKickGuest(uint guestID)
        {
            var ___ret = __Internal.HostKickGuest(__Instance, guestID);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSendUserData(uint guestID, uint id, sbyte* text)
        {
            var ___ret = __Internal.HostSendUserData(__Instance, guestID, id, text);
            return ___ret;
        }

        public bool HostPollEvents(uint timeout, global::ParsecSharp.HostEvent @event)
        {
            var ____arg1 = @event.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.HostPollEvents(__Instance, timeout, __arg1);
            return ___ret;
        }

        public global::ParsecSharp.Status HostAllowGuest(sbyte* attemptID, bool allow)
        {
            var ___ret = __Internal.HostAllowGuest(__Instance, attemptID, allow);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSetPermissions(uint guestID, global::ParsecSharp.Permissions perms)
        {
            var ____arg1 = perms.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.HostSetPermissions(__Instance, guestID, __arg1);
            return ___ret;
        }

        public bool HostPollInput(uint timeout, global::ParsecSharp.Guest guest, global::ParsecSharp.Message msg)
        {
            var ____arg1 = guest.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ____arg2 = msg.__Instance;
            var __arg2 = new __IntPtr(&____arg2);
            var ___ret = __Internal.HostPollInput(__Instance, timeout, __arg1, __arg2);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSubmitAudio(global::ParsecSharp.PCMFormat format, uint sampleRate, byte* pcm, uint frames)
        {
            var ___ret = __Internal.HostSubmitAudio(__Instance, format, sampleRate, pcm, frames);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSubmitCursor(global::ParsecSharp.Cursor cursor, byte* image)
        {
            var ____arg0 = cursor.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var ___ret = __Internal.HostSubmitCursor(__Instance, __arg0, image);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSubmitRumble(uint guestID, uint gamepadID, byte motorBig, byte motorSmall)
        {
            var ___ret = __Internal.HostSubmitRumble(__Instance, guestID, gamepadID, motorBig, motorSmall);
            return ___ret;
        }

        public global::ParsecSharp.Status HostGLSubmitFrame(uint frame)
        {
            var ___ret = __Internal.HostGLSubmitFrame(__Instance, frame);
            return ___ret;
        }

        public global::ParsecSharp.Status HostD3D11SubmitFrame(__IntPtr device, __IntPtr context, __IntPtr frame)
        {
            var ___ret = __Internal.HostD3D11SubmitFrame(__Instance, device, context, frame);
            return ___ret;
        }

        internal static global::ParsecSharp.Status Init(uint ver, global::ParsecSharp.Config cfg, __IntPtr reserved, __IntPtr ps)
        {
            var ____arg1 = cfg.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.Init(ver, __arg1, reserved, ps);
            return ___ret;
        }

        public static void Free(__IntPtr ptr)
        {
            __Internal.Free(ptr);
        }

        public static void SetLogCallback(global::ParsecSharp.LogCallback callback, __IntPtr opaque)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SetLogCallback(__arg0, opaque);
        }

        public static uint Version()
        {
            var ___ret = __Internal.Version();
            return ___ret;
        }
    }

    /// <summary>Video frame properties.</summary>
    /// <remarks>Passed through ::ParsecFrameCallback after calling ::ParsecClientPollFrame.</remarks>
    public unsafe partial struct Frame
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.ColorFormat format;
            internal uint size;
            internal uint width;
            internal uint height;
            internal uint fullWidth;
            internal uint fullHeight;
        }

        private Frame.__Internal __instance;
        internal Frame.__Internal __Instance => __instance;

        internal static Frame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Frame(native.ToPointer(), skipVTables);
        }

        internal static Frame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Frame(native, skipVTables);
        }

        private Frame(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Frame(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Frame.__Internal*) native;
        }

        /// <summary>Color format.</summary>
        public global::ParsecSharp.ColorFormat Format
        {
            get
            {
                return __instance.format;
            }

            set
            {
                __instance.format = value;
            }
        }

        /// <summary>Size in bytes of the `image` buffer parameter of ::ParsecFrameCallback.</summary>
        public uint Size
        {
            get
            {
                return __instance.size;
            }

            set
            {
                __instance.size = value;
            }
        }

        /// <summary>Width in pixels of the visible area of the frame.</summary>
        public uint Width
        {
            get
            {
                return __instance.width;
            }

            set
            {
                __instance.width = value;
            }
        }

        /// <summary>Height in pixels of the visible area of the frame.</summary>
        public uint Height
        {
            get
            {
                return __instance.height;
            }

            set
            {
                __instance.height = value;
            }
        }

        /// <summary>Actual width of the frame including padding.</summary>
        public uint FullWidth
        {
            get
            {
                return __instance.fullWidth;
            }

            set
            {
                __instance.fullWidth = value;
            }
        }

        /// <summary>Actual height of the frame including padding.</summary>
        public uint FullHeight
        {
            get
            {
                return __instance.fullHeight;
            }

            set
            {
                __instance.fullHeight = value;
            }
        }
    }

    /// <summary>Cursor properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecClientCursorEvent, which is itself a member of ::ParsecClientEvent,</para>
    /// <para>returned by ::ParsecClientPollEvents. Also passed to ::ParsecHostSubmitCursor to update the cursor while</para>
    /// <para>in ::HOST_GAME. When polled from ::ParsecClientPollEvents, `positionX` and `positionY` are</para>
    /// <para>affected by the values set via ::ParsecClientSetDimensions.</para>
    /// </remarks>
    public unsafe partial struct Cursor
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint size;
            internal uint positionX;
            internal uint positionY;
            internal ushort width;
            internal ushort height;
            internal ushort hotX;
            internal ushort hotY;
            internal byte modeUpdate;
            internal byte imageUpdate;
            internal byte relative;
            internal fixed byte __pad[1];
        }

        private Cursor.__Internal __instance;
        internal Cursor.__Internal __Instance => __instance;

        internal static Cursor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Cursor(native.ToPointer(), skipVTables);
        }

        internal static Cursor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Cursor(native, skipVTables);
        }

        private Cursor(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Cursor(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Cursor.__Internal*) native;
        }

        /// <summary>Size in bytes of the cursor image buffer.</summary>
        public uint Size
        {
            get
            {
                return __instance.size;
            }

            set
            {
                __instance.size = value;
            }
        }

        /// <summary>When leaving relative mode, the horizontal position in screen coordinates where the cursor reappears.</summary>
        public uint PositionX
        {
            get
            {
                return __instance.positionX;
            }

            set
            {
                __instance.positionX = value;
            }
        }

        /// <summary>When leaving relative mode, the vertical position in screen coordinates where the cursor reappears.</summary>
        public uint PositionY
        {
            get
            {
                return __instance.positionY;
            }

            set
            {
                __instance.positionY = value;
            }
        }

        /// <summary>Width of the cursor image in pixels.</summary>
        public ushort Width
        {
            get
            {
                return __instance.width;
            }

            set
            {
                __instance.width = value;
            }
        }

        /// <summary>Height of the cursor position in pixels.</summary>
        public ushort Height
        {
            get
            {
                return __instance.height;
            }

            set
            {
                __instance.height = value;
            }
        }

        /// <summary>Horizontal pixel position of the cursor hotspot within the image.</summary>
        public ushort HotX
        {
            get
            {
                return __instance.hotX;
            }

            set
            {
                __instance.hotX = value;
            }
        }

        /// <summary>Vertical pixel position of the cursor hotspot within the image.</summary>
        public ushort HotY
        {
            get
            {
                return __instance.hotY;
            }

            set
            {
                __instance.hotY = value;
            }
        }

        /// <summary>`true` if the cursor mode should be updated. The `relative`, `positionX`, and `positionY` members are valid.</summary>
        public bool ModeUpdate
        {
            get
            {
                return __instance.modeUpdate != 0;
            }

            set
            {
                __instance.modeUpdate = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the cursor image should be updated. The `width`, `height`, `hotX`, `hotY`, and `size` members are valid.</summary>
        public bool ImageUpdate
        {
            get
            {
                return __instance.imageUpdate != 0;
            }

            set
            {
                __instance.imageUpdate = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if in relative mode, meaning the client should submit mouse motion in relative distances rather than absolute screen coordinates.</summary>
        public bool Relative
        {
            get
            {
                return __instance.relative != 0;
            }

            set
            {
                __instance.relative = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 1);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 1; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Guest input permissions.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostSetPermissions. Only relevant in ::HOST_DESKTOP.</remarks>
    public unsafe partial struct Permissions
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte gamepad;
            internal byte keyboard;
            internal byte mouse;
            internal fixed byte __pad[1];
        }

        private Permissions.__Internal __instance;
        internal Permissions.__Internal __Instance => __instance;

        internal static Permissions __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Permissions(native.ToPointer(), skipVTables);
        }

        internal static Permissions __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Permissions(native, skipVTables);
        }

        private Permissions(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Permissions(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Permissions.__Internal*) native;
        }

        /// <summary>The guest can send gamepad input.</summary>
        public bool Gamepad
        {
            get
            {
                return __instance.gamepad != 0;
            }

            set
            {
                __instance.gamepad = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>The guest can send keyboard input.</summary>
        public bool Keyboard
        {
            get
            {
                return __instance.keyboard != 0;
            }

            set
            {
                __instance.keyboard = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>The guest can send mouse button.</summary>
        public bool Mouse
        {
            get
            {
                return __instance.mouse != 0;
            }

            set
            {
                __instance.mouse = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 1);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 1; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Latency performance metrics.</summary>
    /// <remarks>Member of ::ParsecGuest and ::ParsecClientStatus.</remarks>
    public unsafe partial struct Metrics
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float encodeLatency;
            internal float decodeLatency;
            internal float networkLatency;
        }

        private Metrics.__Internal __instance;
        internal Metrics.__Internal __Instance => __instance;

        internal static Metrics __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Metrics(native.ToPointer(), skipVTables);
        }

        internal static Metrics __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Metrics(native, skipVTables);
        }

        private Metrics(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Metrics(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Metrics.__Internal*) native;
        }

        /// <summary>Average time in milliseconds for the host to encode a frame.</summary>
        public float EncodeLatency
        {
            get
            {
                return __instance.encodeLatency;
            }

            set
            {
                __instance.encodeLatency = value;
            }
        }

        /// <summary>Average time in milliseconds for the client to decode a frame.</summary>
        public float DecodeLatency
        {
            get
            {
                return __instance.decodeLatency;
            }

            set
            {
                __instance.decodeLatency = value;
            }
        }

        /// <summary>Average round trip time between the client and host.</summary>
        public float NetworkLatency
        {
            get
            {
                return __instance.networkLatency;
            }

            set
            {
                __instance.networkLatency = value;
            }
        }
    }

    /// <summary>Guest properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecGuestStateChangeEvent and ::ParsecUserDataEvent. Returned by ::ParsecHostGetGuests</para>
    /// <para>and ::ParsecHostPollInput.</para>
    /// </remarks>
    public unsafe partial struct Guest
    {
        [StructLayout(LayoutKind.Sequential, Size = 408)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Permissions.__Internal perms;
            internal global::ParsecSharp.Metrics.__Internal metrics;
            internal global::ParsecSharp.GuestState state;
            internal uint id;
            internal uint userID;
            internal fixed sbyte name[320];
            internal fixed sbyte attemptID[56];
            internal byte owner;
            internal fixed byte __pad[3];
        }

        private Guest.__Internal __instance;
        internal Guest.__Internal __Instance => __instance;

        internal static Guest __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Guest(native.ToPointer(), skipVTables);
        }

        internal static Guest __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Guest(native, skipVTables);
        }

        private Guest(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Guest(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Guest.__Internal*) native;
        }

        /// <summary>Guest input permissions. ::HOST_DESKTOP only.</summary>
        public global::ParsecSharp.Permissions Perms;

        /// <summary>Latency performance metrics, only valid in state ::GUEST_CONNECTED.</summary>
        public global::ParsecSharp.Metrics Metrics;

        /// <summary>Guest connection lifecycle states.</summary>
        public global::ParsecSharp.GuestState State
        {
            get
            {
                return __instance.state;
            }

            set
            {
                __instance.state = value;
            }
        }

        /// <summary>Guest ID passed to various host functions.</summary>
        public uint Id
        {
            get
            {
                return __instance.id;
            }

            set
            {
                __instance.id = value;
            }
        }

        /// <summary>Parsec unique user ID.</summary>
        public uint UserID
        {
            get
            {
                return __instance.userID;
            }

            set
            {
                __instance.userID = value;
            }
        }

        /// <summary>UTF-8 null-terminated name guest name string.</summary>
        public sbyte[] Name
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.name)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 320);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.name)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 320; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>Unique connection ID valid while `state` is ::GUEST_WAITING, otherwise filled with zeroes. ::HOST_DESKTOP only.</summary>
        public sbyte[] AttemptID
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.attemptID)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 56);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.attemptID)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 56; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>The guest is also the owner of the host computer. ::HOST_DESKTOP only.</summary>
        public bool Owner
        {
            get
            {
                return __instance.owner != 0;
            }

            set
            {
                __instance.owner = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Keyboard message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial struct KeyboardMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Keycode code;
            internal global::ParsecSharp.Keymod mod;
            internal byte pressed;
            internal fixed byte __pad[3];
        }

        private KeyboardMessage.__Internal __instance;
        internal KeyboardMessage.__Internal __Instance => __instance;

        internal static KeyboardMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new KeyboardMessage(native.ToPointer(), skipVTables);
        }

        internal static KeyboardMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new KeyboardMessage(native, skipVTables);
        }

        private KeyboardMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private KeyboardMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.KeyboardMessage.__Internal*) native;
        }

        /// <summary>Keyboard input.</summary>
        public global::ParsecSharp.Keycode Code
        {
            get
            {
                return __instance.code;
            }

            set
            {
                __instance.code = value;
            }
        }

        /// <summary>Stateful modifier keys applied to keyboard input.</summary>
        public global::ParsecSharp.Keymod Mod
        {
            get
            {
                return __instance.mod;
            }

            set
            {
                __instance.mod = value;
            }
        }

        /// <summary>`true` if pressed, `false` if released.</summary>
        public bool Pressed
        {
            get
            {
                return __instance.pressed != 0;
            }

            set
            {
                __instance.pressed = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Mouse button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial struct MouseButtonMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.MouseButton button;
            internal byte pressed;
            internal fixed byte __pad[3];
        }

        private MouseButtonMessage.__Internal __instance;
        internal MouseButtonMessage.__Internal __Instance => __instance;

        internal static MouseButtonMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MouseButtonMessage(native.ToPointer(), skipVTables);
        }

        internal static MouseButtonMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseButtonMessage(native, skipVTables);
        }

        private MouseButtonMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private MouseButtonMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.MouseButtonMessage.__Internal*) native;
        }

        /// <summary>Mouse button.</summary>
        public global::ParsecSharp.MouseButton Button
        {
            get
            {
                return __instance.button;
            }

            set
            {
                __instance.button = value;
            }
        }

        /// <summary>`true` if clicked, `false` if released.</summary>
        public bool Pressed
        {
            get
            {
                return __instance.pressed != 0;
            }

            set
            {
                __instance.pressed = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Mouse wheel message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial struct MouseWheelMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;
        }

        private MouseWheelMessage.__Internal __instance;
        internal MouseWheelMessage.__Internal __Instance => __instance;

        internal static MouseWheelMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MouseWheelMessage(native.ToPointer(), skipVTables);
        }

        internal static MouseWheelMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseWheelMessage(native, skipVTables);
        }

        private MouseWheelMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private MouseWheelMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.MouseWheelMessage.__Internal*) native;
        }

        /// <summary>Horizontal delta of mouse wheel rotation. Negative values scroll left.</summary>
        public int X
        {
            get
            {
                return __instance.x;
            }

            set
            {
                __instance.x = value;
            }
        }

        /// <summary>Vertical delta of mouse wheel rotation. Negative values scroll up.</summary>
        public int Y
        {
            get
            {
                return __instance.y;
            }

            set
            {
                __instance.y = value;
            }
        }
    }

    /// <summary>Mouse motion message.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecMessage. Mouse motion can be sent in either relative or absolute mode via</para>
    /// <para>the `relative` member. Absolute mode treats the `x` and `y` values as the exact destination for where</para>
    /// <para>the cursor will appear. These values are sent from the client in device screen coordinates and are translated</para>
    /// <para>in accordance with the values set via ::ParsecClientSetDimensions. Relative mode `x` and `y` values are not</para>
    /// <para>affected by ::ParsecClientSetDimensions and move the cursor with a signed delta value from its previous location.</para>
    /// </remarks>
    public unsafe partial struct MouseMotionMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;
            internal byte relative;
            internal fixed byte __pad[3];
        }

        private MouseMotionMessage.__Internal __instance;
        internal MouseMotionMessage.__Internal __Instance => __instance;

        internal static MouseMotionMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MouseMotionMessage(native.ToPointer(), skipVTables);
        }

        internal static MouseMotionMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseMotionMessage(native, skipVTables);
        }

        private MouseMotionMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private MouseMotionMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.MouseMotionMessage.__Internal*) native;
        }

        /// <summary>The absolute horizontal screen coordinate of the cursor  if `relative` is `false`, or the delta (can be negative) if `relative` is `true`.</summary>
        public int X
        {
            get
            {
                return __instance.x;
            }

            set
            {
                __instance.x = value;
            }
        }

        /// <summary>The absolute vertical screen coordinate of the cursor if `relative` is `false`, or the delta (can be negative) if `relative` is `true`.</summary>
        public int Y
        {
            get
            {
                return __instance.y;
            }

            set
            {
                __instance.y = value;
            }
        }

        /// <summary>`true` for relative mode, `false` for absolute mode. See above.</summary>
        public bool Relative
        {
            get
            {
                return __instance.relative != 0;
            }

            set
            {
                __instance.relative = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Gamepad button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial struct GamepadButtonMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.GamepadButton button;
            internal uint id;
            internal byte pressed;
            internal fixed byte __pad[3];
        }

        private GamepadButtonMessage.__Internal __instance;
        internal GamepadButtonMessage.__Internal __Instance => __instance;

        internal static GamepadButtonMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GamepadButtonMessage(native.ToPointer(), skipVTables);
        }

        internal static GamepadButtonMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadButtonMessage(native, skipVTables);
        }

        private GamepadButtonMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private GamepadButtonMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.GamepadButtonMessage.__Internal*) native;
        }

        /// <summary>Gamepad button.</summary>
        public global::ParsecSharp.GamepadButton Button
        {
            get
            {
                return __instance.button;
            }

            set
            {
                __instance.button = value;
            }
        }

        /// <summary>Unique client-provided index identifying the gamepad.</summary>
        public uint Id
        {
            get
            {
                return __instance.id;
            }

            set
            {
                __instance.id = value;
            }
        }

        /// <summary>`true` if the button was pressed, `false` if released.</summary>
        public bool Pressed
        {
            get
            {
                return __instance.pressed != 0;
            }

            set
            {
                __instance.pressed = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Gamepad axis message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial struct GamepadAxisMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.GamepadAxis axis;
            internal uint id;
            internal short value;
            internal fixed byte __pad[2];
        }

        private GamepadAxisMessage.__Internal __instance;
        internal GamepadAxisMessage.__Internal __Instance => __instance;

        internal static GamepadAxisMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GamepadAxisMessage(native.ToPointer(), skipVTables);
        }

        internal static GamepadAxisMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadAxisMessage(native, skipVTables);
        }

        private GamepadAxisMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private GamepadAxisMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.GamepadAxisMessage.__Internal*) native;
        }

        /// <summary>Gamepad axes related to thumbsticks and triggers.</summary>
        public global::ParsecSharp.GamepadAxis Axis
        {
            get
            {
                return __instance.axis;
            }

            set
            {
                __instance.axis = value;
            }
        }

        /// <summary>Unique client-provided index identifying the gamepad.</summary>
        public uint Id
        {
            get
            {
                return __instance.id;
            }

            set
            {
                __instance.id = value;
            }
        }

        /// <summary>The new value of the axis between -32,768 (left/down) and 32,767 (right/up).</summary>
        public short Value
        {
            get
            {
                return __instance.value;
            }

            set
            {
                __instance.value = value;
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Gamepad unplug message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial struct GamepadUnplugMessage
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;
        }

        private GamepadUnplugMessage.__Internal __instance;
        internal GamepadUnplugMessage.__Internal __Instance => __instance;

        internal static GamepadUnplugMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GamepadUnplugMessage(native.ToPointer(), skipVTables);
        }

        internal static GamepadUnplugMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadUnplugMessage(native, skipVTables);
        }

        private GamepadUnplugMessage(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private GamepadUnplugMessage(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.GamepadUnplugMessage.__Internal*) native;
        }

        /// <summary>Unique client-provided index identifying the gamepad.</summary>
        public uint Id
        {
            get
            {
                return __instance.id;
            }

            set
            {
                __instance.id = value;
            }
        }
    }

    /// <summary>Generic input message that can represent any message type.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientSendMessage or returned by ::ParsecHostPollInput while</para>
    /// <para>in ::HOST_GAME. The application can switch on the `type` member to see which `Message`</para>
    /// <para>struct should be evaluated. The `Message` structs are unioned.</para>
    /// </remarks>
    public unsafe partial struct Message
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ParsecSharp.MessageType type;

            [FieldOffset(4)]
            internal global::ParsecSharp.KeyboardMessage.__Internal keyboard;

            [FieldOffset(4)]
            internal global::ParsecSharp.MouseButtonMessage.__Internal mouseButton;

            [FieldOffset(4)]
            internal global::ParsecSharp.MouseWheelMessage.__Internal mouseWheel;

            [FieldOffset(4)]
            internal global::ParsecSharp.MouseMotionMessage.__Internal mouseMotion;

            [FieldOffset(4)]
            internal global::ParsecSharp.GamepadButtonMessage.__Internal gamepadButton;

            [FieldOffset(4)]
            internal global::ParsecSharp.GamepadAxisMessage.__Internal gamepadAxis;

            [FieldOffset(4)]
            internal global::ParsecSharp.GamepadUnplugMessage.__Internal gamepadUnplug;
        }

        private Message.__Internal __instance;
        internal Message.__Internal __Instance => __instance;

        internal static Message __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Message(native.ToPointer(), skipVTables);
        }

        internal static Message __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Message(native, skipVTables);
        }

        private Message(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Message(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.Message.__Internal*) native;
        }

        /// <summary>Input message type.</summary>
        public global::ParsecSharp.MessageType Type
        {
            get
            {
                return __instance.type;
            }

            set
            {
                __instance.type = value;
            }
        }

        /// <summary>Keyboard message.</summary>
        public global::ParsecSharp.KeyboardMessage Keyboard;

        /// <summary>Mouse button message.</summary>
        public global::ParsecSharp.MouseButtonMessage MouseButton;

        /// <summary>Mouse wheel message.</summary>
        public global::ParsecSharp.MouseWheelMessage MouseWheel;

        /// <summary>Mouse motion message.</summary>
        public global::ParsecSharp.MouseMotionMessage MouseMotion;

        /// <summary>Gamepad button message.</summary>
        public global::ParsecSharp.GamepadButtonMessage GamepadButton;

        /// <summary>Gamepad axis message.</summary>
        public global::ParsecSharp.GamepadAxisMessage GamepadAxis;

        /// <summary>Gamepad unplug message.</summary>
        public global::ParsecSharp.GamepadUnplugMessage GamepadUnplug;
    }

    /// <summary>Client configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientConnect. Regarding `resolutionX`, `resolutionY`, and `refreshRate`:</para>
    /// <para>These settings apply only in ::HOST_DESKTOP if the client is the first client to connect, and that client is</para>
    /// <para>the owner of the computer. Setting `resolutionX` or `resolutionY` to `0` will leave the host resolution unaffected,</para>
    /// <para>otherwise the host will attempt to find the closest matching resolution / refresh rate.</para>
    /// </remarks>
    public unsafe partial struct ClientConfig
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int decoderSoftware;
            internal int mediaContainer;
            internal int protocol;
            internal int resolutionX;
            internal int resolutionY;
            internal int refreshRate;
            internal byte pngCursor;
            internal fixed byte __pad[3];
        }

        private ClientConfig.__Internal __instance;
        internal ClientConfig.__Internal __Instance => __instance;

        internal static ClientConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ClientConfig(native.ToPointer(), skipVTables);
        }

        internal static ClientConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientConfig(native, skipVTables);
        }

        private ClientConfig(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ClientConfig(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.ClientConfig.__Internal*) native;
        }

        /// <summary>`true` to force decoding of video frames via a software implementation.</summary>
        public int DecoderSoftware
        {
            get
            {
                return __instance.decoderSoftware;
            }

            set
            {
                __instance.decoderSoftware = value;
            }
        }

        /// <summary>::ParsecContainer value.</summary>
        public int MediaContainer
        {
            get
            {
                return __instance.mediaContainer;
            }

            set
            {
                __instance.mediaContainer = value;
            }
        }

        /// <summary>::ParsecProtocol value.</summary>
        public int Protocol
        {
            get
            {
                return __instance.protocol;
            }

            set
            {
                __instance.protocol = value;
            }
        }

        /// <summary>See above.</summary>
        public int ResolutionX
        {
            get
            {
                return __instance.resolutionX;
            }

            set
            {
                __instance.resolutionX = value;
            }
        }

        /// <summary>See above.</summary>
        public int ResolutionY
        {
            get
            {
                return __instance.resolutionY;
            }

            set
            {
                __instance.resolutionY = value;
            }
        }

        /// <summary>See above.</summary>
        public int RefreshRate
        {
            get
            {
                return __instance.refreshRate;
            }

            set
            {
                __instance.refreshRate = value;
            }
        }

        /// <summary>`true` to return compressed PNG cursor images during ::ParsecClientPollEvents, `false` to return a 32-bit RGBA image.</summary>
        public bool PngCursor
        {
            get
            {
                return __instance.pngCursor != 0;
            }

            set
            {
                __instance.pngCursor = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Client connection health and status information.</summary>
    /// <remarks>Returned by ::ParsecClientGetStatus.</remarks>
    public unsafe partial struct ClientStatus
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Metrics.__Internal metrics;
            internal fixed sbyte attemptID[56];
            internal byte networkFailure;
            internal byte decoderFallback;
            internal fixed byte __pad[1];
        }

        private ClientStatus.__Internal __instance;
        internal ClientStatus.__Internal __Instance => __instance;

        internal static ClientStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ClientStatus(native.ToPointer(), skipVTables);
        }

        internal static ClientStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientStatus(native, skipVTables);
        }

        private ClientStatus(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ClientStatus(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.ClientStatus.__Internal*) native;
        }

        /// <summary>Latency performance metrics.</summary>
        public global::ParsecSharp.Metrics Metrics;

        /// <summary>Most recent connection `attemptID`. Valid even if ::ParsecClientConnect does not return ::PARSEC_OK.</summary>
        public sbyte[] AttemptID
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.attemptID)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 56);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.attemptID)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 56; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>Client is currently experiencing network failure.</summary>
        public bool NetworkFailure
        {
            get
            {
                return __instance.networkFailure != 0;
            }

            set
            {
                __instance.networkFailure = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the client had to fallback to software decoding after being unable to internally initialize a hardware accelerated decoder.</summary>
        public bool DecoderFallback
        {
            get
            {
                return __instance.decoderFallback != 0;
            }

            set
            {
                __instance.decoderFallback = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 1);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 1; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Cursor mode/image update event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public unsafe partial struct ClientCursorEvent
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Cursor.__Internal cursor;
            internal uint key;
        }

        private ClientCursorEvent.__Internal __instance;
        internal ClientCursorEvent.__Internal __Instance => __instance;

        internal static ClientCursorEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ClientCursorEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientCursorEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientCursorEvent(native, skipVTables);
        }

        private ClientCursorEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ClientCursorEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.ClientCursorEvent.__Internal*) native;
        }

        /// <summary>Cursor properties.</summary>
        public global::ParsecSharp.Cursor Cursor;

        /// <summary>Buffer lookup key passed to ::ParsecGetBuffer to retrieve the cursor image, if available.</summary>
        public uint Key
        {
            get
            {
                return __instance.key;
            }

            set
            {
                __instance.key = value;
            }
        }
    }

    /// <summary>Gamepad rumble data event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public unsafe partial struct ClientRumbleEvent
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint gamepadID;
            internal byte motorBig;
            internal byte motorSmall;
            internal fixed byte __pad[2];
        }

        private ClientRumbleEvent.__Internal __instance;
        internal ClientRumbleEvent.__Internal __Instance => __instance;

        internal static ClientRumbleEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ClientRumbleEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientRumbleEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientRumbleEvent(native, skipVTables);
        }

        private ClientRumbleEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ClientRumbleEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.ClientRumbleEvent.__Internal*) native;
        }

        /// <summary>Unique client-assigned index identifying the gamepad connected to the client.</summary>
        public uint GamepadID
        {
            get
            {
                return __instance.gamepadID;
            }

            set
            {
                __instance.gamepadID = value;
            }
        }

        /// <summary>8-bit unsigned value for large motor vibration.</summary>
        public byte MotorBig
        {
            get
            {
                return __instance.motorBig;
            }

            set
            {
                __instance.motorBig = value;
            }
        }

        /// <summary>8-bit unsigned value for small motor vibration.</summary>
        public byte MotorSmall
        {
            get
            {
                return __instance.motorSmall;
            }

            set
            {
                __instance.motorSmall = value;
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>User-defined host message event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public unsafe partial struct ClientUserDataEvent
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint id;
            internal uint key;
        }

        private ClientUserDataEvent.__Internal __instance;
        internal ClientUserDataEvent.__Internal __Instance => __instance;

        internal static ClientUserDataEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ClientUserDataEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientUserDataEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientUserDataEvent(native, skipVTables);
        }

        private ClientUserDataEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ClientUserDataEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.ClientUserDataEvent.__Internal*) native;
        }

        /// <summary>User-defined message ID set by the host.</summary>
        public uint Id
        {
            get
            {
                return __instance.id;
            }

            set
            {
                __instance.id = value;
            }
        }

        /// <summary>Buffer lookup key passed to ::ParsecGetBuffer to retrieve the message.</summary>
        public uint Key
        {
            get
            {
                return __instance.key;
            }

            set
            {
                __instance.key = value;
            }
        }
    }

    /// <summary>Generic client event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecClientPollEvents. The application can switch on the `type` member to see</para>
    /// <para>which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    public unsafe partial struct ClientEvent
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ParsecSharp.ClientEventType type;

            [FieldOffset(4)]
            internal global::ParsecSharp.ClientCursorEvent.__Internal cursor;

            [FieldOffset(4)]
            internal global::ParsecSharp.ClientRumbleEvent.__Internal rumble;

            [FieldOffset(4)]
            internal global::ParsecSharp.ClientUserDataEvent.__Internal userData;
        }

        private ClientEvent.__Internal __instance;
        internal ClientEvent.__Internal __Instance => __instance;

        internal static ClientEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ClientEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientEvent(native, skipVTables);
        }

        private ClientEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private ClientEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.ClientEvent.__Internal*) native;
        }

        /// <summary>Client event type.</summary>
        public global::ParsecSharp.ClientEventType Type
        {
            get
            {
                return __instance.type;
            }

            set
            {
                __instance.type = value;
            }
        }

        /// <summary>Cursor mode/image update event.</summary>
        public global::ParsecSharp.ClientCursorEvent Cursor;

        /// <summary>Gamepad rumble data event.</summary>
        public global::ParsecSharp.ClientRumbleEvent Rumble;

        /// <summary>User-defined host message event.</summary>
        public global::ParsecSharp.ClientUserDataEvent UserData;
    }

    /// <summary>Host configuration.</summary>
    /// <remarks>Member of ::ParsecHostStatus, passed to ::ParsecHostStart and ::ParsecHostSetConfig.</remarks>
    public unsafe partial struct HostConfig
    {
        [StructLayout(LayoutKind.Sequential, Size = 880)]
        public partial struct __Internal
        {
            internal int resolutionX;
            internal int resolutionY;
            internal int refreshRate;
            internal int adminMute;
            internal int exclusiveInput;
            internal int encoderFPS;
            internal int encoderMaxBitrate;
            internal int encoderH265;
            internal int maxGuests;
            internal fixed sbyte name[256];
            internal fixed sbyte desc[512];
            internal fixed sbyte gameID[72];
            internal byte publicGame;
            internal fixed byte __pad[3];
        }

        private HostConfig.__Internal __instance;
        internal HostConfig.__Internal __Instance => __instance;

        internal static HostConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new HostConfig(native.ToPointer(), skipVTables);
        }

        internal static HostConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HostConfig(native, skipVTables);
        }

        private HostConfig(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private HostConfig(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.HostConfig.__Internal*) native;
        }

        /// <summary>Resolution width. ::HOST_DESKTOP owner only.</summary>
        public int ResolutionX
        {
            get
            {
                return __instance.resolutionX;
            }

            set
            {
                __instance.resolutionX = value;
            }
        }

        /// <summary>Resolution height. ::HOST_DESKTOP owner only.</summary>
        public int ResolutionY
        {
            get
            {
                return __instance.resolutionY;
            }

            set
            {
                __instance.resolutionY = value;
            }
        }

        /// <summary>Refresh rate in Hz. ::HOST_DESKTOP owner only.</summary>
        public int RefreshRate
        {
            get
            {
                return __instance.refreshRate;
            }

            set
            {
                __instance.refreshRate = value;
            }
        }

        /// <summary>Mute local audio on owner connection. ::HOST_DESKTOP owner only.</summary>
        public int AdminMute
        {
            get
            {
                return __instance.adminMute;
            }

            set
            {
                __instance.adminMute = value;
            }
        }

        /// <summary>Block remote input when local host input occurs. ::HOST_DESKTOP only.</summary>
        public int ExclusiveInput
        {
            get
            {
                return __instance.exclusiveInput;
            }

            set
            {
                __instance.exclusiveInput = value;
            }
        }

        /// <summary>Desired frames per second.</summary>
        public int EncoderFPS
        {
            get
            {
                return __instance.encoderFPS;
            }

            set
            {
                __instance.encoderFPS = value;
            }
        }

        /// <summary>Maximum output bitrate in Mbps, split between guests.</summary>
        public int EncoderMaxBitrate
        {
            get
            {
                return __instance.encoderMaxBitrate;
            }

            set
            {
                __instance.encoderMaxBitrate = value;
            }
        }

        /// <summary>Allow H.265 codec.</summary>
        public int EncoderH265
        {
            get
            {
                return __instance.encoderH265;
            }

            set
            {
                __instance.encoderH265 = value;
            }
        }

        /// <summary>Total number of guests allowed at once. This number should not include the local host.</summary>
        public int MaxGuests
        {
            get
            {
                return __instance.maxGuests;
            }

            set
            {
                __instance.maxGuests = value;
            }
        }

        /// <summary>UTF-8 null-terminated name string. May be zeroed to use hostname.</summary>
        public sbyte[] Name
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.name)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 256);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.name)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 256; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>UTF-8 null-terminated description string. ::HOST_GAME only.</summary>
        public sbyte[] Desc
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.desc)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 512);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.desc)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 512; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>Game unique identifier issued by Parsec. ::HOST_GAME only.</summary>
        public sbyte[] GameID
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.gameID)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 72);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.gameID)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 72; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        /// <summary>Set to `true` to allow the hosting session to be visible publicly in the Parsec Arcade. ::HOST_GAME only.</summary>
        public bool PublicGame
        {
            get
            {
                return __instance.publicGame != 0;
            }

            set
            {
                __instance.publicGame = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 3);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 3; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Host runtime status.</summary>
    /// <remarks>Returned by ::ParsecHostGetStatus.</remarks>
    public unsafe partial struct HostStatus
    {
        [StructLayout(LayoutKind.Sequential, Size = 888)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.HostConfig.__Internal cfg;
            internal uint numGuests;
            internal byte running;
            internal byte invalidSessionID;
            internal byte gamepadSupport;
            internal fixed byte __pad[1];
        }

        private HostStatus.__Internal __instance;
        internal HostStatus.__Internal __Instance => __instance;

        internal static HostStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new HostStatus(native.ToPointer(), skipVTables);
        }

        internal static HostStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HostStatus(native, skipVTables);
        }

        private HostStatus(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private HostStatus(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.HostStatus.__Internal*) native;
        }

        /// <summary>The currently active host configuration.</summary>
        public global::ParsecSharp.HostConfig Cfg;

        /// <summary>The number of guests currently in state ::GUEST_CONNECTED.</summary>
        public uint NumGuests
        {
            get
            {
                return __instance.numGuests;
            }

            set
            {
                __instance.numGuests = value;
            }
        }

        /// <summary>The host is currently accepting guests after calling ::ParsecHostStart.</summary>
        public bool Running
        {
            get
            {
                return __instance.running != 0;
            }

            set
            {
                __instance.running = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the host's Session ID has become invalid. The host must call ::ParsecHostSetConfig with a valid `sessionID` to continue hosting.</summary>
        public bool InvalidSessionID
        {
            get
            {
                return __instance.invalidSessionID != 0;
            }

            set
            {
                __instance.invalidSessionID = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the virtual gamepad driver is working properly, otherwise `false`. ::HOST_DESKTOP only.</summary>
        public bool GamepadSupport
        {
            get
            {
                return __instance.gamepadSupport != 0;
            }

            set
            {
                __instance.gamepadSupport = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 1);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.__pad)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 1; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    /// <summary>Guest connection state change event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    public unsafe partial struct GuestStateChangeEvent
    {
        [StructLayout(LayoutKind.Sequential, Size = 408)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Guest.__Internal guest;
        }

        private GuestStateChangeEvent.__Internal __instance;
        internal GuestStateChangeEvent.__Internal __Instance => __instance;

        internal static GuestStateChangeEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GuestStateChangeEvent(native.ToPointer(), skipVTables);
        }

        internal static GuestStateChangeEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GuestStateChangeEvent(native, skipVTables);
        }

        private GuestStateChangeEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private GuestStateChangeEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.GuestStateChangeEvent.__Internal*) native;
        }

        /// <summary>Guest properties. The `state` member can be used to evaluate the guest's state change.</summary>
        public global::ParsecSharp.Guest Guest;
    }

    /// <summary>User-defined guest message event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    public unsafe partial struct UserDataEvent
    {
        [StructLayout(LayoutKind.Sequential, Size = 416)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Guest.__Internal guest;
            internal uint id;
            internal uint key;
        }

        private UserDataEvent.__Internal __instance;
        internal UserDataEvent.__Internal __Instance => __instance;

        internal static UserDataEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new UserDataEvent(native.ToPointer(), skipVTables);
        }

        internal static UserDataEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UserDataEvent(native, skipVTables);
        }

        private UserDataEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private UserDataEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.UserDataEvent.__Internal*) native;
        }

        /// <summary>Guest ::ParsecGuest properties.</summary>
        public global::ParsecSharp.Guest Guest;

        /// <summary>User-defined message ID set by the client.</summary>
        public uint Id
        {
            get
            {
                return __instance.id;
            }

            set
            {
                __instance.id = value;
            }
        }

        /// <summary>Buffer lookup key passed to ::ParsecGetBuffer to retrieve the message.</summary>
        public uint Key
        {
            get
            {
                return __instance.key;
            }

            set
            {
                __instance.key = value;
            }
        }
    }

    /// <summary>Generic host event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecHostPollEvents. The application can switch on the `type` member</para>
    /// <para>to see which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    public unsafe partial struct HostEvent
    {
        [StructLayout(LayoutKind.Explicit, Size = 420)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ParsecSharp.HostEventType type;

            [FieldOffset(4)]
            internal global::ParsecSharp.GuestStateChangeEvent.__Internal guestStateChange;

            [FieldOffset(4)]
            internal global::ParsecSharp.UserDataEvent.__Internal userData;
        }

        private HostEvent.__Internal __instance;
        internal HostEvent.__Internal __Instance => __instance;

        internal static HostEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new HostEvent(native.ToPointer(), skipVTables);
        }

        internal static HostEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HostEvent(native, skipVTables);
        }

        private HostEvent(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private HostEvent(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::ParsecSharp.HostEvent.__Internal*) native;
        }

        /// <summary>Host event type.</summary>
        public global::ParsecSharp.HostEventType Type
        {
            get
            {
                return __instance.type;
            }

            set
            {
                __instance.type = value;
            }
        }

        /// <summary>Guest connection state change event.</summary>
        public global::ParsecSharp.GuestStateChangeEvent GuestStateChange;

        /// <summary>User-defined guest message event.</summary>
        public global::ParsecSharp.UserDataEvent UserData;
    }
}
