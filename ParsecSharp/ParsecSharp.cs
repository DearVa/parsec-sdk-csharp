// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace ParsecSharp
{
    /// <summary>Status codes indicating success, warning, or error.</summary>
    /// <remarks>
    /// <para>Returned by most Parsec SDK functions. ::PARSEC_OK is `0`,</para>
    /// <para>warnings are positive, errors are negative.</para>
    /// </remarks>
    public enum Status
    {
        /// <summary>0</summary>
        ParsecOk = 0,
        /// <summary>10</summary>
        WarnContinue = 10,
        /// <summary>4</summary>
        HostWarnShutdown = 4,
        /// <summary>5</summary>
        HostWarnKicked = 5,
        /// <summary>6</summary>
        ConnectWarnApproval = 6,
        /// <summary>8</summary>
        ConnectWarnDeclined = 8,
        /// <summary>9</summary>
        ConnectWarnCanceled = 9,
        /// <summary>99</summary>
        ConnectWarnPeerGone = 99,
        /// <summary>1000</summary>
        DecodeWarnContinue = 1000,
        /// <summary>1001</summary>
        DecodeWarnAccepted = 1001,
        /// <summary>1003</summary>
        DecodeWarnReinit = 1003,
        /// <summary>2000</summary>
        NetworkWarnTimeout = 2000,
        /// <summary>5000</summary>
        QueueWarnEmpty = 5000,
        /// <summary>5001</summary>
        QueueWarnNoBuffer = 5001,
        /// <summary>5003</summary>
        QueueWarnTimeout = 5003,
        /// <summary>6000</summary>
        AudioWarnNoData = 6000,
        /// <summary>-1</summary>
        ErrorDefault = -1,
        /// <summary>-3</summary>
        ParsecNotRunning = -3,
        /// <summary>-4</summary>
        ParsecAlreadyRunning = -4,
        /// <summary>-5</summary>
        ParsecNotImplemented = -5,
        /// <summary>-10</summary>
        DecodeErrorInit = -10,
        /// <summary>-11</summary>
        DecodeErrorLoad = -11,
        /// <summary>-13</summary>
        DecodeErrorMap = -13,
        /// <summary>-14</summary>
        DecodeErrorDecode = -14,
        /// <summary>-15</summary>
        DecodeErrorCleanup = -15,
        /// <summary>-16</summary>
        DecodeErrorParse = -16,
        /// <summary>-17</summary>
        DecodeErrorNoSupport = -17,
        /// <summary>-18</summary>
        DecodeErrorPixelFormat = -18,
        /// <summary>-19</summary>
        DecodeErrorBuffer = -19,
        /// <summary>-20</summary>
        DecodeErrorResolution = -20,
        /// <summary>-6101</summary>
        WebsocketErrorConnect = -6101,
        /// <summary>-3001</summary>
        WebsocketErrorPoll = -3001,
        /// <summary>-3002</summary>
        WebsocketErrorRead = -3002,
        /// <summary>-3003</summary>
        WebsocketErrorWrite = -3003,
        /// <summary>-6105</summary>
        WebsocketErrorClose = -6105,
        /// <summary>-3005</summary>
        WebsocketErrorPing = -3005,
        /// <summary>-3006</summary>
        WebsocketErrorPongTimeout = -3006,
        /// <summary>-3007</summary>
        WebsocketErrorPong = -3007,
        /// <summary>-3008</summary>
        WebsocketErrorAuth = -3008,
        /// <summary>-3009</summary>
        WebsocketErrorGoingAway = -3009,
        /// <summary>-5000</summary>
        ZlibErrorDeflate = -5000,
        /// <summary>-5001</summary>
        ZlibErrorInflate = -5001,
        /// <summary>-6023</summary>
        NatErrorPeerPhase = -6023,
        /// <summary>-6024</summary>
        NatErrorStunPhase = -6024,
        /// <summary>-6033</summary>
        NatErrorNoCandidates = -6033,
        /// <summary>-6111</summary>
        NatErrorJsonAction = -6111,
        /// <summary>-6112</summary>
        NatErrorNoSocket = -6112,
        /// <summary>-7000</summary>
        OpenGlErrorContext = -7000,
        /// <summary>-7001</summary>
        OpenGlErrorShare = -7001,
        /// <summary>-7002</summary>
        OpenGlErrorPixformat = -7002,
        /// <summary>-7003</summary>
        OpenGlErrorCurrent = -7003,
        /// <summary>-7004</summary>
        OpenGlErrorDc = -7004,
        /// <summary>-7005</summary>
        OpenGlErrorShader = -7005,
        /// <summary>-7006</summary>
        OpenGlErrorProgram = -7006,
        /// <summary>-7007</summary>
        OpenGlErrorVersion = -7007,
        /// <summary>-7008</summary>
        OpenGlErrorTexture = -7008,
        /// <summary>-8000</summary>
        JsonErrorParse = -8000,
        /// <summary>-8001</summary>
        JsonErrorMissing = -8001,
        /// <summary>-8002</summary>
        JsonErrorType = -8002,
        /// <summary>-8003</summary>
        JsonErrorValType = -8003,
        /// <summary>-8004</summary>
        JsonErrorBuffer = -8004,
        /// <summary>-8005</summary>
        JsonErrorFopen = -8005,
        /// <summary>-8006</summary>
        JsonErrorFread = -8006,
        /// <summary>-8007</summary>
        JsonErrorFwrite = -8007,
        /// <summary>-9000</summary>
        AudioErrorInit = -9000,
        /// <summary>-9001</summary>
        AudioErrorCapture = -9001,
        /// <summary>-9002</summary>
        AudioErrorNetwork = -9002,
        /// <summary>-9003</summary>
        AudioErrorFree = -9003,
        /// <summary>-9004</summary>
        AudioErrorPlay = -9004,
        /// <summary>-10000</summary>
        AudioOpusErrorInit = -10000,
        /// <summary>-10001</summary>
        AudioOpusErrorDecode = -10001,
        /// <summary>-10002</summary>
        AudioOpusErrorEncode = -10002,
        /// <summary>-12007</summary>
        NetworkErrorBgTimeout = -12007,
        /// <summary>-12008</summary>
        NetworkErrorBadPacket = -12008,
        /// <summary>-12011</summary>
        NetworkErrorBuffer = -12011,
        /// <summary>-12017</summary>
        NetworkErrorShutdown = -12017,
        /// <summary>-12018</summary>
        NetworkErrorUnsupported = -12018,
        /// <summary>-12019</summary>
        NetworkErrorInterrupted = -12019,
        /// <summary>-13000</summary>
        ServerErrorDisplay = -13000,
        /// <summary>-13008</summary>
        ServerErrorResolution = -13008,
        /// <summary>-13009</summary>
        ServerErrorMaxResolution = -13009,
        /// <summary>-13011</summary>
        ServerErrorNoUser = -13011,
        /// <summary>-13012</summary>
        ServerErrorNoRoom = -13012,
        /// <summary>-13013</summary>
        ServerErrorVideoDone = -13013,
        /// <summary>-13014</summary>
        ServerErrorClientAbort = -13014,
        /// <summary>-13015</summary>
        ServerErrorClientGone = -13015,
        /// <summary>-14003</summary>
        CaptureErrorInit = -14003,
        /// <summary>-14004</summary>
        CaptureErrorTexture = -14004,
        /// <summary>-15000</summary>
        EncodeErrorInit = -15000,
        /// <summary>-15002</summary>
        EncodeErrorEncode = -15002,
        /// <summary>-15006</summary>
        EncodeErrorBuffer = -15006,
        /// <summary>-15100</summary>
        EncodeErrorProperties = -15100,
        /// <summary>-15101</summary>
        EncodeErrorLibrary = -15101,
        /// <summary>-15007</summary>
        EncodeErrorSession = -15007,
        /// <summary>-15103</summary>
        EncodeErrorSession1 = -15103,
        /// <summary>-15104</summary>
        EncodeErrorSession2 = -15104,
        /// <summary>-15105</summary>
        EncodeErrorOutputInit = -15105,
        /// <summary>-15106</summary>
        EncodeErrorTexture = -15106,
        /// <summary>-15107</summary>
        EncodeErrorOutput = -15107,
        /// <summary>-15108</summary>
        EncodeErrorUnsupported = -15108,
        /// <summary>-15109</summary>
        EncodeErrorHandle = -15109,
        /// <summary>-15110</summary>
        EncodeErrorCaps = -15110,
        /// <summary>-19000</summary>
        UpnpError = -19000,
        /// <summary>-22000</summary>
        D3dErrorTexture = -22000,
        /// <summary>-22001</summary>
        D3dErrorShader = -22001,
        /// <summary>-22002</summary>
        D3dErrorBuffer = -22002,
        /// <summary>-22003</summary>
        D3dErrorLayout = -22003,
        /// <summary>-22004</summary>
        D3dErrorDevice = -22004,
        /// <summary>-22005</summary>
        D3dErrorMt = -22005,
        /// <summary>-22006</summary>
        D3dErrorAdapter = -22006,
        /// <summary>-22007</summary>
        D3dErrorFactory = -22007,
        /// <summary>-22008</summary>
        D3dErrorOutput = -22008,
        /// <summary>-22009</summary>
        D3dErrorContext = -22009,
        /// <summary>-22010</summary>
        D3dErrorOutput1 = -22010,
        /// <summary>-22011</summary>
        D3dErrorSwapChain = -22011,
        /// <summary>-22012</summary>
        D3dErrorDraw = -22012,
        /// <summary>-22013</summary>
        D3dErrorOutput5 = -22013,
        /// <summary>-23000</summary>
        H26xErrorNotFound = -23000,
        /// <summary>-28000</summary>
        AesGcmErrorKeyLen = -28000,
        /// <summary>-28001</summary>
        AesGcmErrorEncrypt = -28001,
        /// <summary>-28002</summary>
        AesGcmErrorDecrypt = -28002,
        /// <summary>-28003</summary>
        AesGcmErrorCtx = -28003,
        /// <summary>-28004</summary>
        AesGcmErrorBuffer = -28004,
        /// <summary>-28005</summary>
        AesGcmErrorOverflow = -28005,
        /// <summary>-32000</summary>
        SctpErrorGlobalInit = -32000,
        /// <summary>-32001</summary>
        SctpErrorWrite = -32001,
        /// <summary>-32002</summary>
        SctpErrorSocket = -32002,
        /// <summary>-32003</summary>
        SctpErrorBind = -32003,
        /// <summary>-32004</summary>
        SctpErrorConnect = -32004,
        /// <summary>-33000</summary>
        DtlsErrorBioWrite = -33000,
        /// <summary>-33001</summary>
        DtlsErrorBioRead = -33001,
        /// <summary>-33002</summary>
        DtlsErrorSsl = -33002,
        /// <summary>-33003</summary>
        DtlsErrorBuffer = -33003,
        /// <summary>-33004</summary>
        DtlsErrorNoData = -33004,
        /// <summary>-33005</summary>
        DtlsErrorCert = -33005,
        /// <summary>-34000</summary>
        StunErrorPacket = -34000,
        /// <summary>-34001</summary>
        StunErrorParseHeader = -34001,
        /// <summary>-34002</summary>
        StunErrorParseAddress = -34002,
        /// <summary>-35000</summary>
        SoErrorOpen = -35000,
        /// <summary>-35001</summary>
        SoErrorSymbol = -35001,
        /// <summary>-36000</summary>
        ParsecErrorVersion = -36000,
        /// <summary>-36001</summary>
        ParsecErrorVerData = -36001,
        /// <summary>-37000</summary>
        ResampleErrorInit = -37000,
        /// <summary>-37001</summary>
        ResampleErrorResample = -37001,
        /// <summary>Caused when the graphics render engine isn't supported in Unity.</summary>
        UnityUnsupportedEngine = -38000,
        /// <summary>`SSL_get_error` value will be subtracted from this value.</summary>
        OpensslError = -600000,
        /// <summary>`WSAGetLastError` value will be subtracted from this value.</summary>
        SocketError = -700000,
    }

    /// <summary>Log level.</summary>
    /// <remarks>Passed through ::ParsecLogCallback set with ::ParsecSetLogCallback.</remarks>
    public enum LogLevel
    {
        /// <summary>Messages interesting to support staff trying to figure out the context of an issue.</summary>
        Info = 105,
        /// <summary>Messages interesting to developers trying to debug an issue.</summary>
        Debug = 100,
    }

    /// <summary>Keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage.</remarks>
    public enum Keycode
    {
        /// <summary>4</summary>
        A = 4,
        /// <summary>5</summary>
        B = 5,
        /// <summary>6</summary>
        C = 6,
        /// <summary>7</summary>
        D = 7,
        /// <summary>8</summary>
        E = 8,
        /// <summary>9</summary>
        F = 9,
        /// <summary>10</summary>
        G = 10,
        /// <summary>11</summary>
        H = 11,
        /// <summary>12</summary>
        I = 12,
        /// <summary>13</summary>
        J = 13,
        /// <summary>14</summary>
        K = 14,
        /// <summary>15</summary>
        L = 15,
        /// <summary>16</summary>
        M = 16,
        /// <summary>17</summary>
        N = 17,
        /// <summary>18</summary>
        O = 18,
        /// <summary>19</summary>
        P = 19,
        /// <summary>20</summary>
        Q = 20,
        /// <summary>21</summary>
        R = 21,
        /// <summary>22</summary>
        S = 22,
        /// <summary>23</summary>
        T = 23,
        /// <summary>24</summary>
        U = 24,
        /// <summary>25</summary>
        V = 25,
        /// <summary>26</summary>
        W = 26,
        /// <summary>27</summary>
        X = 27,
        /// <summary>28</summary>
        Y = 28,
        /// <summary>29</summary>
        Z = 29,
        /// <summary>30</summary>
        Digital1 = 30,
        /// <summary>31</summary>
        Digital2 = 31,
        /// <summary>32</summary>
        Digital3 = 32,
        /// <summary>33</summary>
        Digital4 = 33,
        /// <summary>34</summary>
        Digital5 = 34,
        /// <summary>35</summary>
        Digital6 = 35,
        /// <summary>36</summary>
        Digital7 = 36,
        /// <summary>37</summary>
        Digital8 = 37,
        /// <summary>38</summary>
        Digital9 = 38,
        /// <summary>39</summary>
        Digital0 = 39,
        /// <summary>40</summary>
        Enter = 40,
        /// <summary>41</summary>
        Escape = 41,
        /// <summary>42</summary>
        Backspace = 42,
        /// <summary>43</summary>
        Tab = 43,
        /// <summary>44</summary>
        Space = 44,
        /// <summary>45</summary>
        Minus = 45,
        /// <summary>46</summary>
        Equals = 46,
        /// <summary>47</summary>
        LeftBracket = 47,
        /// <summary>48</summary>
        RightBracket = 48,
        /// <summary>49</summary>
        Backslash = 49,
        /// <summary>51</summary>
        Semicolon = 51,
        /// <summary>52</summary>
        Apostrophe = 52,
        /// <summary>53</summary>
        Backtick = 53,
        /// <summary>54</summary>
        Comma = 54,
        /// <summary>55</summary>
        Period = 55,
        /// <summary>56</summary>
        Slash = 56,
        /// <summary>57</summary>
        CapsLock = 57,
        /// <summary>58</summary>
        F1 = 58,
        /// <summary>59</summary>
        F2 = 59,
        /// <summary>60</summary>
        F3 = 60,
        /// <summary>61</summary>
        F4 = 61,
        /// <summary>62</summary>
        F5 = 62,
        /// <summary>63</summary>
        F6 = 63,
        /// <summary>64</summary>
        F7 = 64,
        /// <summary>65</summary>
        F8 = 65,
        /// <summary>66</summary>
        F9 = 66,
        /// <summary>67</summary>
        F10 = 67,
        /// <summary>68</summary>
        F11 = 68,
        /// <summary>69</summary>
        F12 = 69,
        /// <summary>70</summary>
        PrintScreen = 70,
        /// <summary>71</summary>
        ScrollLock = 71,
        /// <summary>72</summary>
        Pause = 72,
        /// <summary>73</summary>
        Insert = 73,
        /// <summary>74</summary>
        Home = 74,
        /// <summary>75</summary>
        PageUp = 75,
        /// <summary>76</summary>
        Delete = 76,
        /// <summary>77</summary>
        End = 77,
        /// <summary>78</summary>
        PageDown = 78,
        /// <summary>79</summary>
        Right = 79,
        /// <summary>80</summary>
        Left = 80,
        /// <summary>81</summary>
        Down = 81,
        /// <summary>82</summary>
        Up = 82,
        /// <summary>83</summary>
        NumLock = 83,
        /// <summary>84</summary>
        NumPadDivide = 84,
        /// <summary>85</summary>
        NumPadMultiply = 85,
        /// <summary>86</summary>
        NumPadMinus = 86,
        /// <summary>87</summary>
        NumPadPlus = 87,
        /// <summary>88</summary>
        NumPadEnter = 88,
        /// <summary>89</summary>
        NumPad1 = 89,
        /// <summary>90</summary>
        NumPad2 = 90,
        /// <summary>91</summary>
        NumPad3 = 91,
        /// <summary>92</summary>
        NumPad4 = 92,
        /// <summary>93</summary>
        NumPad5 = 93,
        /// <summary>94</summary>
        NumPad6 = 94,
        /// <summary>95</summary>
        NumPad7 = 95,
        /// <summary>96</summary>
        NumPad8 = 96,
        /// <summary>97</summary>
        NumPad9 = 97,
        /// <summary>98</summary>
        NumPad0 = 98,
        /// <summary>99</summary>
        NumPadPeriod = 99,
        /// <summary>101</summary>
        Application = 101,
        /// <summary>104</summary>
        F13 = 104,
        /// <summary>105</summary>
        F14 = 105,
        /// <summary>106</summary>
        F15 = 106,
        /// <summary>107</summary>
        F16 = 107,
        /// <summary>108</summary>
        F17 = 108,
        /// <summary>109</summary>
        F18 = 109,
        /// <summary>110</summary>
        F19 = 110,
        /// <summary>118</summary>
        Menu = 118,
        /// <summary>127</summary>
        Mute = 127,
        /// <summary>128</summary>
        VolumeUp = 128,
        /// <summary>129</summary>
        VolumeDown = 129,
        /// <summary>224</summary>
        LeftCtrl = 224,
        /// <summary>225</summary>
        LeftShift = 225,
        /// <summary>226</summary>
        LeftAlt = 226,
        /// <summary>227</summary>
        LeftGui = 227,
        /// <summary>228</summary>
        RightCtrl = 228,
        /// <summary>229</summary>
        RightShift = 229,
        /// <summary>230</summary>
        RightAlt = 230,
        /// <summary>231</summary>
        RightGui = 231,
        /// <summary>258</summary>
        AudioNext = 258,
        /// <summary>259</summary>
        AudioPrevious = 259,
        /// <summary>260</summary>
        AudioStop = 260,
        /// <summary>261</summary>
        AudioPlay = 261,
        /// <summary>262</summary>
        AudioMute = 262,
        /// <summary>263</summary>
        MediaSelect = 263,
    }

    /// <summary>Stateful modifier keys applied to keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage. These values may be bitwise OR'd together.</remarks>
    public enum Keymod
    {
        /// <summary>No stateful modifier key active.</summary>
        None = 0,
        /// <summary>`NUMLOCK` is currently active.</summary>
        Num = 4096,
        /// <summary>`CAPSLOCK` is currently active.</summary>
        Caps = 8192,
    }

    /// <summary>Mouse button.</summary>
    /// <remarks>Member of ::ParsecMouseButtonMessage.</remarks>
    public enum MouseButton
    {
        /// <summary>Left mouse button.</summary>
        L = 1,
        /// <summary>Middle mouse button.</summary>
        Middle = 2,
        /// <summary>Right mouse button.</summary>
        R = 3,
        /// <summary>Extra mouse button 1.</summary>
        X1 = 4,
        /// <summary>Extra mouse button 2.</summary>
        X2 = 5,
    }

    /// <summary>Gamepad button.</summary>
    /// <remarks>Member of ::ParsecGamepadButtonMessage.</remarks>
    public enum GamepadButton
    {
        /// <summary>A button.</summary>
        A = 0,
        /// <summary>B button.</summary>
        B = 1,
        /// <summary>X button.</summary>
        X = 2,
        /// <summary>Y button.</summary>
        Y = 3,
        /// <summary>Back button.</summary>
        Back = 4,
        /// <summary>Guide button.</summary>
        Guide = 5,
        /// <summary>Start button.</summary>
        Start = 6,
        /// <summary>Left thumbstick button.</summary>
        LeftStick = 7,
        /// <summary>Right thumbstick button.</summary>
        RightStick = 8,
        /// <summary>Left shoulder (bumper) button.</summary>
        LeftShoulder = 9,
        /// <summary>Right shoulder (bumper) button.</summary>
        RightShoulder = 10,
        /// <summary>Analog DPAD up.</summary>
        DpadUp = 11,
        /// <summary>Analog DPAD down.</summary>
        DpadDown = 12,
        /// <summary>Analog DPAD left.</summary>
        DpadLeft = 13,
        /// <summary>Analog DPAD right.</summary>
        DpadRight = 14,
    }

    /// <summary>Gamepad axes related to thumbsticks and triggers.</summary>
    /// <remarks>Member of ::ParsecGamepadAxisMessage.</remarks>
    public enum GamepadAxis
    {
        /// <summary>Gamepad left thumbstick x-axis.</summary>
        LeftX = 0,
        /// <summary>Gamepad left thumbstick y-axis.</summary>
        LeftY = 1,
        /// <summary>Gamepad right thumbstick x-axis.</summary>
        RightX = 2,
        /// <summary>Gamepad right thumbstick y-axis.</summary>
        RightY = 3,
        /// <summary>Gamepad left trigger value.</summary>
        LeftTrigger = 4,
        /// <summary>Gamepad right trigger value.</summary>
        RightTrigger = 5,
    }

    /// <summary>Input message type.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public enum MessageType
    {
        /// <summary>`keyboard` ::ParsecKeyboardMessage is valid in ::ParsecMessage.</summary>
        Keyboard = 1,
        /// <summary>`mouseButton` ::ParsecMouseButtonMessage is valid in ::ParsecMessage.</summary>
        MouseButton = 2,
        /// <summary>`mouseWheel` ::ParsecMouseWheelMessage is valid in ::ParsecMessage.</summary>
        MouseWheel = 3,
        /// <summary>`mouseMotion` ::ParsecMouseMotionMessage is valid in ::ParsecMessage.</summary>
        MouseMotion = 4,
        /// <summary>`gamepadButton` ::ParsecGamepadButtonMessage is valid in ::ParsecMessage.</summary>
        GamepadButton = 5,
        /// <summary>`gamepadAxis` ::ParsecGamepadAxisMessage is valid in ::ParsecMessage.</summary>
        GamepadAxis = 6,
        /// <summary>`gamepadUnplug` ::ParsecGamepadUnplugMessage is valid in ::ParsecMessage.</summary>
        GamepadUnplug = 7,
    }

    /// <summary>Color formats for raw image data.</summary>
    /// <remarks>Member of ::ParsecFrame.</remarks>
    public enum ColorFormat
    {
        Unknown = 0,
        /// <summary>4:2:0 full width/height Y plane followed by an interleaved half width/height UV plane.</summary>
        Nv12 = 1,
        /// <summary>4:2:0 full width/height Y plane followed by a half width/height U plane followed by a half width/height V plane.</summary>
        I420 = 2,
        /// <summary>4:2:2 full width/height Y plane followed by an interleaved half width full height UV plane.</summary>
        Nv16 = 3,
        /// <summary>4:2:2 full width/height Y plane followed by a half width full height U plane followed by a half width full height V plane.</summary>
        I422 = 4,
        /// <summary>32-bits per pixel, 8-bits per channel BGRA.</summary>
        Bgra = 5,
        /// <summary>32-bits per pixel, 8-bits per channel RGBA.</summary>
        Rgba = 6,
    }

    /// <summary>Network protocol used for peer-to-peer connections.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    public enum Protocol
    {
        /// <summary>Parsec's low-latency optimized BUD protocol.</summary>
        Bud = 1,
        /// <summary>SCTP protocol compatible with WebRTC data channels.</summary>
        Sctp = 2,
    }

    /// <summary>Video stream container.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    public enum Container
    {
        /// <summary>Parsec's custom container compatible with native decoding.</summary>
        Parsec = 0,
        /// <summary>MP4 box container compatible with web browser Media Source Extensions.</summary>
        Mp4 = 2,
    }

    /// <summary>PCM audio format.</summary>
    /// <remarks>Passed to ::ParsecHostSubmitAudio.</remarks>
    public enum PCMFormat
    {
        /// <summary>32-bit floating point samples.</summary>
        Float = 1,
        /// <summary>16-bit signed integer samples.</summary>
        Int16 = 2,
    }

    /// <summary>Guest connection lifecycle states.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostGetGuests.</remarks>
    public enum GuestState
    {
        /// <summary>The guest is currently waiting for the host to allow them via ::ParsecHostAllowGuest. ::HOST_DESKTOP only.</summary>
        Waiting = 1,
        /// <summary>The guest is attempting to make a peer-to-peer connection to the host.</summary>
        Connecting = 2,
        /// <summary>The guest successfully connected.</summary>
        Connected = 4,
        /// <summary>The guest disconnected.</summary>
        Disconnected = 8,
        /// <summary>The guest failed peer-to-peer negotiation.</summary>
        Failed = 16,
    }

    /// <summary>Host mode of operation.</summary>
    /// <remarks>Passed to ::ParsecHostStart.</remarks>
    public enum HostMode
    {
        /// <summary>The host intends to share their entire desktop. Permission and approval systems apply. Windows only.</summary>
        Desktop = 1,
        /// <summary>Parsec is integrated into a game. The game uses the `Submit` model to provide output.</summary>
        Game = 2,
    }

    /// <summary>Host event type.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    public enum HostEventType
    {
        /// <summary>A guest has changed connection state, `guestStateChange` is valid in ::ParsecHostEvent.</summary>
        GuestStateChange = 1,
        /// <summary>User-defined message from a guest, `userData is valid in ::ParsecHostEvent.</summary>
        UserData = 2,
        /// <summary>The host's Session ID has become invalid.</summary>
        InvalidSessionId = 4,
    }

    /// <summary>Client event type.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public enum ClientEventType
    {
        /// <summary>A cursor mode change or image update is available, `cursor` is valid in ::ParsecClientEvent. Call ::ParsecGetBuffer in the case of an image update.</summary>
        Cursor = 1,
        /// <summary>Gamepad rumble event, `rumble` is valid in ::ParsecClientEvent.</summary>
        Rumble = 2,
        /// <summary>User-defined message from the host, `userData` is valid in ::ParsecClientEvent.</summary>
        UserData = 3,
        /// <summary>The client has been temporarily blocked from sending input and receiving host output.</summary>
        Blocked = 4,
        /// <summary>The client has returned to normal operation after receiving a ::CLIENT_EVENT_BLOCKED.</summary>
        Unblocked = 5,
    }

    /// <summary>Status codes indicating success, warning, or error.</summary>
    /// <remarks>
    /// <para>Returned by most Parsec SDK functions. ::PARSEC_OK is `0`,</para>
    /// <para>warnings are positive, errors are negative.</para>
    /// </remarks>
    /// <summary>Log level.</summary>
    /// <remarks>Passed through ::ParsecLogCallback set with ::ParsecSetLogCallback.</remarks>
    /// <summary>Keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage.</remarks>
    /// <summary>Stateful modifier keys applied to keyboard input.</summary>
    /// <remarks>Member of ::ParsecKeyboardMessage. These values may be bitwise OR'd together.</remarks>
    /// <summary>Mouse button.</summary>
    /// <remarks>Member of ::ParsecMouseButtonMessage.</remarks>
    /// <summary>Gamepad button.</summary>
    /// <remarks>Member of ::ParsecGamepadButtonMessage.</remarks>
    /// <summary>Gamepad axes related to thumbsticks and triggers.</summary>
    /// <remarks>Member of ::ParsecGamepadAxisMessage.</remarks>
    /// <summary>Input message type.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Color formats for raw image data.</summary>
    /// <remarks>Member of ::ParsecFrame.</remarks>
    /// <summary>Network protocol used for peer-to-peer connections.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    /// <summary>Video stream container.</summary>
    /// <remarks>Member of ::ParsecClientConfig.</remarks>
    /// <summary>PCM audio format.</summary>
    /// <remarks>Passed to ::ParsecHostSubmitAudio.</remarks>
    /// <summary>Guest connection lifecycle states.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostGetGuests.</remarks>
    /// <summary>Host mode of operation.</summary>
    /// <remarks>Passed to ::ParsecHostStart.</remarks>
    /// <summary>Host event type.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    /// <summary>Client event type.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>::Parsec instance configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecInit and returned by ::ParsecGetConfig. `clientPort` and `hostPort`</para>
    /// <para>serve as the first port used when the `bind` call is made internally. If the port is already in use,</para>
    /// <para>the next port will be tried until an open port has been found or 50 attempts have been made.</para>
    /// </remarks>
    /// <summary>Video frame properties.</summary>
    /// <remarks>Passed through ::ParsecFrameCallback after calling ::ParsecClientPollFrame.</remarks>
    /// <summary>Cursor properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecClientCursorEvent, which is itself a member of ::ParsecClientEvent,</para>
    /// <para>returned by ::ParsecClientPollEvents. Also passed to ::ParsecHostSubmitCursor to update the cursor while</para>
    /// <para>in ::HOST_GAME. When polled from ::ParsecClientPollEvents, `positionX` and `positionY` are</para>
    /// <para>affected by the values set via ::ParsecClientSetDimensions.</para>
    /// </remarks>
    /// <summary>Guest input permissions.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostSetPermissions. Only relevant in ::HOST_DESKTOP.</remarks>
    /// <summary>Latency performance metrics.</summary>
    /// <remarks>Member of ::ParsecGuest and ::ParsecClientStatus.</remarks>
    /// <summary>Guest properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecGuestStateChangeEvent and ::ParsecUserDataEvent. Returned by ::ParsecHostGetGuests</para>
    /// <para>and ::ParsecHostPollInput.</para>
    /// </remarks>
    /// <summary>Keyboard message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Mouse button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Mouse wheel message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Mouse motion message.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecMessage. Mouse motion can be sent in either relative or absolute mode via</para>
    /// <para>the `relative` member. Absolute mode treats the `x` and `y` values as the exact destination for where</para>
    /// <para>the cursor will appear. These values are sent from the client in device screen coordinates and are translated</para>
    /// <para>in accordance with the values set via ::ParsecClientSetDimensions. Relative mode `x` and `y` values are not</para>
    /// <para>affected by ::ParsecClientSetDimensions and move the cursor with a signed delta value from its previous location.</para>
    /// </remarks>
    /// <summary>Gamepad button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Gamepad axis message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Gamepad unplug message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    /// <summary>Generic input message that can represent any message type.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientSendMessage or returned by ::ParsecHostPollInput while</para>
    /// <para>in ::HOST_GAME. The application can switch on the `type` member to see which `Message`</para>
    /// <para>struct should be evaluated. The `Message` structs are unioned.</para>
    /// </remarks>
    /// <summary>Client configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientConnect. Regarding `resolutionX`, `resolutionY`, and `refreshRate`:</para>
    /// <para>These settings apply only in ::HOST_DESKTOP if the client is the first client to connect, and that client is</para>
    /// <para>the owner of the computer. Setting `resolutionX` or `resolutionY` to `0` will leave the host resolution unaffected,</para>
    /// <para>otherwise the host will attempt to find the closest matching resolution / refresh rate.</para>
    /// </remarks>
    /// <summary>Client connection health and status information.</summary>
    /// <remarks>Returned by ::ParsecClientGetStatus.</remarks>
    /// <summary>Cursor mode/image update event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>Gamepad rumble data event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>User-defined host message event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    /// <summary>Generic client event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecClientPollEvents. The application can switch on the `type` member to see</para>
    /// <para>which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    /// <summary>Host configuration.</summary>
    /// <remarks>Member of ::ParsecHostStatus, passed to ::ParsecHostStart and ::ParsecHostSetConfig.</remarks>
    /// <summary>Host runtime status.</summary>
    /// <remarks>Returned by ::ParsecHostGetStatus.</remarks>
    /// <summary>Guest connection state change event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    /// <summary>User-defined guest message event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    /// <summary>Generic host event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecHostPollEvents. The application can switch on the `type` member</para>
    /// <para>to see which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    /// <summary>OpenGL/GLES 32-bit unsigned integer.</summary>
    /// <remarks>Passed to ::ParsecHostGLSubmitFrame. Prevents obligatory include of GL headers.</remarks>
    /// <summary>D3D11 `ID3D11Device`.</summary>
    /// <remarks>Passed to ::ParsecHostD3D11SubmitFrame. Prevents obligatory include of d3d11.h.</remarks>
    /// <summary>D3D11 `ID3D11DeviceContext`.</summary>
    /// <remarks>Passed to ::ParsecHostD3D11SubmitFrame. Prevents obligatory include of d3d11.h.</remarks>
    /// <summary>D3D11 `ID3D11Texture2D`.</summary>
    /// <remarks>Passed to ::ParsecHostD3D11SubmitFrame. Prevents obligatory include of d3d11.h.</remarks>
    /// <summary>Fired when a new log message is available from the Parsec SDK.</summary>
    /// <param name="level">::ParsecLogLevel level value.</param>
    /// <param name="msg">Null-terminated UTF-8 string containing the full log message.</param>
    /// <param name="opaque">User supplied context passed to ::ParsecSetLogCallback.</param>
    /// <remarks>Passed to ::ParsecSetLogCallback.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void LogCallback(global::ParsecSharp.LogLevel level, sbyte* msg, __IntPtr opaque);

    /// <summary>Fired synchronously if a new frame is available from the host.</summary>
    /// <param name="frame">Video frame properties.</param>
    /// <param name="image">The video frame buffer containing image data.</param>
    /// <param name="opaque">User supplied context passed to ::ParsecClientPollFrame.</param>
    /// <remarks>Passed to ::ParsecClientPollFrame.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void FrameCallback(__IntPtr frame, byte* image, __IntPtr opaque);

    /// <summary>Fired synchronously if new audio is available from the host.</summary>
    /// <param name="pcm">16-bit signed, two channel, 48KHz PCM audio samples.</param>
    /// <param name="frames">Number of audio frames.</param>
    /// <param name="opaque">User supplied context passed to ::ParsecClientPollAudio.</param>
    /// <remarks>Passed to ::ParsecClientPollAudio.</remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void AudioCallback(short* pcm, uint frames, __IntPtr opaque);

    /// <summary>::Parsec instance configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecInit and returned by ::ParsecGetConfig. `clientPort` and `hostPort`</para>
    /// <para>serve as the first port used when the `bind` call is made internally. If the port is already in use,</para>
    /// <para>the next port will be tried until an open port has been found or 50 attempts have been made.</para>
    /// </remarks>
    public unsafe partial class Config : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int upnp;
            internal int clientPort;
            internal int hostPort;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Config> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Config>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Config managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Config managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Config __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Config(native.ToPointer(), skipVTables);
        }

        internal static Config __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Config)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Config __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Config(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Config(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Config(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Config()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Config.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Config(global::ParsecSharp.Config _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Config.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Config.__Internal*) __Instance) = *((global::ParsecSharp.Config.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>`1` enables and maintains UPnP to assist NAT traversal, `0` disables it.</summary>
        public int Upnp
        {
            get
            {
                return ((__Internal*)__Instance)->upnp;
            }

            set
            {
                ((__Internal*)__Instance)->upnp = value;
            }
        }

        /// <summary>First port tried for client connections. A value of `0` uses a pseudo random default.</summary>
        public int ClientPort
        {
            get
            {
                return ((__Internal*)__Instance)->clientPort;
            }

            set
            {
                ((__Internal*)__Instance)->clientPort = value;
            }
        }

        /// <summary>First port used to accept host connections. A value of `0` uses a pseudo random default.</summary>
        public int HostPort
        {
            get
            {
                return ((__Internal*)__Instance)->hostPort;
            }

            set
            {
                ((__Internal*)__Instance)->hostPort = value;
            }
        }
    }

    public unsafe partial class Parsec
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecDestroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Destroy(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecGetConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetConfig(__IntPtr __instance, __IntPtr cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecGetBuffer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr GetBuffer(__IntPtr __instance, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientConnect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientConnect(__IntPtr __instance, __IntPtr cfg, sbyte* sessionID, sbyte* peerID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientDisconnect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClientDisconnect(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientGetStatus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientGetStatus(__IntPtr __instance, __IntPtr status);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientSetDimensions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientSetDimensions(__IntPtr __instance, uint width, uint height, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientPollFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientPollFrame(__IntPtr __instance, __IntPtr callback, uint timeout, __IntPtr opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientPollAudio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientPollAudio(__IntPtr __instance, __IntPtr callback, uint timeout, __IntPtr opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientPollEvents", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool ClientPollEvents(__IntPtr __instance, uint timeout, __IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientGLRenderFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientGLRenderFrame(__IntPtr __instance, uint timeout);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientGLDestroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ClientGLDestroy(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientSendMessage", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientSendMessage(__IntPtr __instance, __IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecClientSendUserData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status ClientSendUserData(__IntPtr __instance, uint id, sbyte* text);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostStart", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostStart(__IntPtr __instance, global::ParsecSharp.HostMode mode, __IntPtr cfg, sbyte* sessionID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostStop", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HostStop(__IntPtr __instance);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostGetStatus", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void HostGetStatus(__IntPtr __instance, __IntPtr status);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSetConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSetConfig(__IntPtr __instance, __IntPtr cfg, sbyte* sessionID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostGetGuests", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint HostGetGuests(__IntPtr __instance, global::ParsecSharp.GuestState state, __IntPtr guests);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostKickGuest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostKickGuest(__IntPtr __instance, uint guestID);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSendUserData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSendUserData(__IntPtr __instance, uint guestID, uint id, sbyte* text);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostPollEvents", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HostPollEvents(__IntPtr __instance, uint timeout, __IntPtr @event);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostAllowGuest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostAllowGuest(__IntPtr __instance, sbyte* attemptID, bool allow);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSetPermissions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSetPermissions(__IntPtr __instance, uint guestID, __IntPtr perms);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostPollInput", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            internal static extern bool HostPollInput(__IntPtr __instance, uint timeout, __IntPtr guest, __IntPtr msg);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSubmitAudio", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSubmitAudio(__IntPtr __instance, global::ParsecSharp.PCMFormat format, uint sampleRate, byte* pcm, uint frames);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSubmitCursor", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSubmitCursor(__IntPtr __instance, __IntPtr cursor, byte* image);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostSubmitRumble", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostSubmitRumble(__IntPtr __instance, uint guestID, uint gamepadID, byte motorBig, byte motorSmall);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostGLSubmitFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostGLSubmitFrame(__IntPtr __instance, uint frame);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecHostD3D11SubmitFrame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status HostD3D11SubmitFrame(__IntPtr __instance, __IntPtr device, __IntPtr context, __IntPtr frame);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecInit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::ParsecSharp.Status Init(uint ver, __IntPtr cfg, __IntPtr reserved, __IntPtr ps);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecFree", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void Free(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecSetLogCallback", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetLogCallback(__IntPtr callback, __IntPtr opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("parsec", EntryPoint = "ParsecVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint Version();
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Parsec> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Parsec>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Parsec managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Parsec managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Parsec __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Parsec(native.ToPointer(), skipVTables);
        }

        internal static Parsec __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Parsec)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Parsec __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Parsec(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Parsec(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Parsec(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public void Destroy()
        {
            __Internal.Destroy(__Instance);
        }

        public void GetConfig(global::ParsecSharp.Config cfg)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            __Internal.GetConfig(__Instance, __arg0);
        }

        public __IntPtr GetBuffer(uint key)
        {
            var ___ret = __Internal.GetBuffer(__Instance, key);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientConnect(global::ParsecSharp.ClientConfig cfg, sbyte* sessionID, sbyte* peerID)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.ClientConnect(__Instance, __arg0, sessionID, peerID);
            return ___ret;
        }

        public void ClientDisconnect()
        {
            __Internal.ClientDisconnect(__Instance);
        }

        public global::ParsecSharp.Status ClientGetStatus(global::ParsecSharp.ClientStatus status)
        {
            var __arg0 = status is null ? __IntPtr.Zero : status.__Instance;
            var ___ret = __Internal.ClientGetStatus(__Instance, __arg0);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientSetDimensions(uint width, uint height, float scale)
        {
            var ___ret = __Internal.ClientSetDimensions(__Instance, width, height, scale);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientPollFrame(global::ParsecSharp.FrameCallback callback, uint timeout, __IntPtr opaque)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.ClientPollFrame(__Instance, __arg0, timeout, opaque);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientPollAudio(global::ParsecSharp.AudioCallback callback, uint timeout, __IntPtr opaque)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var ___ret = __Internal.ClientPollAudio(__Instance, __arg0, timeout, opaque);
            return ___ret;
        }

        public bool ClientPollEvents(uint timeout, global::ParsecSharp.ClientEvent @event)
        {
            var __arg1 = @event is null ? __IntPtr.Zero : @event.__Instance;
            var ___ret = __Internal.ClientPollEvents(__Instance, timeout, __arg1);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientGLRenderFrame(uint timeout)
        {
            var ___ret = __Internal.ClientGLRenderFrame(__Instance, timeout);
            return ___ret;
        }

        public void ClientGLDestroy()
        {
            __Internal.ClientGLDestroy(__Instance);
        }

        public global::ParsecSharp.Status ClientSendMessage(global::ParsecSharp.Message msg)
        {
            var __arg0 = msg is null ? __IntPtr.Zero : msg.__Instance;
            var ___ret = __Internal.ClientSendMessage(__Instance, __arg0);
            return ___ret;
        }

        public global::ParsecSharp.Status ClientSendUserData(uint id, sbyte* text)
        {
            var ___ret = __Internal.ClientSendUserData(__Instance, id, text);
            return ___ret;
        }

        public global::ParsecSharp.Status HostStart(global::ParsecSharp.HostMode mode, global::ParsecSharp.HostConfig cfg, sbyte* sessionID)
        {
            var __arg1 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.HostStart(__Instance, mode, __arg1, sessionID);
            return ___ret;
        }

        public void HostStop()
        {
            __Internal.HostStop(__Instance);
        }

        public void HostGetStatus(global::ParsecSharp.HostStatus status)
        {
            var __arg0 = status is null ? __IntPtr.Zero : status.__Instance;
            __Internal.HostGetStatus(__Instance, __arg0);
        }

        public global::ParsecSharp.Status HostSetConfig(global::ParsecSharp.HostConfig cfg, sbyte* sessionID)
        {
            var __arg0 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.HostSetConfig(__Instance, __arg0, sessionID);
            return ___ret;
        }

        public uint HostGetGuests(global::ParsecSharp.GuestState state, global::ParsecSharp.Guest guests)
        {
            var ____arg1 = guests is null ? __IntPtr.Zero : guests.__Instance;
            var __arg1 = new __IntPtr(&____arg1);
            var ___ret = __Internal.HostGetGuests(__Instance, state, __arg1);
            return ___ret;
        }

        public global::ParsecSharp.Status HostKickGuest(uint guestID)
        {
            var ___ret = __Internal.HostKickGuest(__Instance, guestID);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSendUserData(uint guestID, uint id, sbyte* text)
        {
            var ___ret = __Internal.HostSendUserData(__Instance, guestID, id, text);
            return ___ret;
        }

        public bool HostPollEvents(uint timeout, global::ParsecSharp.HostEvent @event)
        {
            var __arg1 = @event is null ? __IntPtr.Zero : @event.__Instance;
            var ___ret = __Internal.HostPollEvents(__Instance, timeout, __arg1);
            return ___ret;
        }

        public global::ParsecSharp.Status HostAllowGuest(sbyte* attemptID, bool allow)
        {
            var ___ret = __Internal.HostAllowGuest(__Instance, attemptID, allow);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSetPermissions(uint guestID, global::ParsecSharp.Permissions perms)
        {
            var __arg1 = perms is null ? __IntPtr.Zero : perms.__Instance;
            var ___ret = __Internal.HostSetPermissions(__Instance, guestID, __arg1);
            return ___ret;
        }

        public bool HostPollInput(uint timeout, global::ParsecSharp.Guest guest, global::ParsecSharp.Message msg)
        {
            var __arg1 = guest is null ? __IntPtr.Zero : guest.__Instance;
            var __arg2 = msg is null ? __IntPtr.Zero : msg.__Instance;
            var ___ret = __Internal.HostPollInput(__Instance, timeout, __arg1, __arg2);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSubmitAudio(global::ParsecSharp.PCMFormat format, uint sampleRate, byte* pcm, uint frames)
        {
            var ___ret = __Internal.HostSubmitAudio(__Instance, format, sampleRate, pcm, frames);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSubmitCursor(global::ParsecSharp.Cursor cursor, byte* image)
        {
            var __arg0 = cursor is null ? __IntPtr.Zero : cursor.__Instance;
            var ___ret = __Internal.HostSubmitCursor(__Instance, __arg0, image);
            return ___ret;
        }

        public global::ParsecSharp.Status HostSubmitRumble(uint guestID, uint gamepadID, byte motorBig, byte motorSmall)
        {
            var ___ret = __Internal.HostSubmitRumble(__Instance, guestID, gamepadID, motorBig, motorSmall);
            return ___ret;
        }

        public global::ParsecSharp.Status HostGLSubmitFrame(uint frame)
        {
            var ___ret = __Internal.HostGLSubmitFrame(__Instance, frame);
            return ___ret;
        }

        public global::ParsecSharp.Status HostD3D11SubmitFrame(__IntPtr device, __IntPtr context, __IntPtr frame)
        {
            var ___ret = __Internal.HostD3D11SubmitFrame(__Instance, device, context, frame);
            return ___ret;
        }

        public static global::ParsecSharp.Status Init(uint ver, global::ParsecSharp.Config cfg, __IntPtr reserved, global::ParsecSharp.Parsec ps)
        {
            var __arg1 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ____arg3 = ps is null ? __IntPtr.Zero : ps.__Instance;
            var __arg3 = new __IntPtr(&____arg3);
            var ___ret = __Internal.Init(ver, __arg1, reserved, __arg3);
            return ___ret;
        }

        public static void Free(__IntPtr ptr)
        {
            __Internal.Free(ptr);
        }

        public static void SetLogCallback(global::ParsecSharp.LogCallback callback, __IntPtr opaque)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SetLogCallback(__arg0, opaque);
        }

        public static uint Version()
        {
            var ___ret = __Internal.Version();
            return ___ret;
        }
    }

    /// <summary>Video frame properties.</summary>
    /// <remarks>Passed through ::ParsecFrameCallback after calling ::ParsecClientPollFrame.</remarks>
    public unsafe partial class Frame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.ColorFormat format;
            internal uint size;
            internal uint width;
            internal uint height;
            internal uint fullWidth;
            internal uint fullHeight;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecFrame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Frame> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Frame>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Frame managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Frame managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Frame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Frame(native.ToPointer(), skipVTables);
        }

        internal static Frame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Frame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Frame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Frame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Frame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Frame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Frame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Frame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Frame(global::ParsecSharp.Frame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Frame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Frame.__Internal*) __Instance) = *((global::ParsecSharp.Frame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Color format.</summary>
        public global::ParsecSharp.ColorFormat Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        /// <summary>Size in bytes of the `image` buffer parameter of ::ParsecFrameCallback.</summary>
        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        /// <summary>Width in pixels of the visible area of the frame.</summary>
        public uint Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        /// <summary>Height in pixels of the visible area of the frame.</summary>
        public uint Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        /// <summary>Actual width of the frame including padding.</summary>
        public uint FullWidth
        {
            get
            {
                return ((__Internal*)__Instance)->fullWidth;
            }

            set
            {
                ((__Internal*)__Instance)->fullWidth = value;
            }
        }

        /// <summary>Actual height of the frame including padding.</summary>
        public uint FullHeight
        {
            get
            {
                return ((__Internal*)__Instance)->fullHeight;
            }

            set
            {
                ((__Internal*)__Instance)->fullHeight = value;
            }
        }
    }

    /// <summary>Cursor properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecClientCursorEvent, which is itself a member of ::ParsecClientEvent,</para>
    /// <para>returned by ::ParsecClientPollEvents. Also passed to ::ParsecHostSubmitCursor to update the cursor while</para>
    /// <para>in ::HOST_GAME. When polled from ::ParsecClientPollEvents, `positionX` and `positionY` are</para>
    /// <para>affected by the values set via ::ParsecClientSetDimensions.</para>
    /// </remarks>
    public unsafe partial class Cursor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal uint size;
            internal uint positionX;
            internal uint positionY;
            internal ushort width;
            internal ushort height;
            internal ushort hotX;
            internal ushort hotY;
            internal byte modeUpdate;
            internal byte imageUpdate;
            internal byte relative;
            internal fixed byte __pad[1];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecCursor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Cursor> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Cursor>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Cursor managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Cursor managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Cursor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Cursor(native.ToPointer(), skipVTables);
        }

        internal static Cursor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Cursor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Cursor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Cursor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Cursor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Cursor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Cursor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Cursor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Cursor(global::ParsecSharp.Cursor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Cursor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Cursor.__Internal*) __Instance) = *((global::ParsecSharp.Cursor.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Size in bytes of the cursor image buffer.</summary>
        public uint Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        /// <summary>When leaving relative mode, the horizontal position in screen coordinates where the cursor reappears.</summary>
        public uint PositionX
        {
            get
            {
                return ((__Internal*)__Instance)->positionX;
            }

            set
            {
                ((__Internal*)__Instance)->positionX = value;
            }
        }

        /// <summary>When leaving relative mode, the vertical position in screen coordinates where the cursor reappears.</summary>
        public uint PositionY
        {
            get
            {
                return ((__Internal*)__Instance)->positionY;
            }

            set
            {
                ((__Internal*)__Instance)->positionY = value;
            }
        }

        /// <summary>Width of the cursor image in pixels.</summary>
        public ushort Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        /// <summary>Height of the cursor position in pixels.</summary>
        public ushort Height
        {
            get
            {
                return ((__Internal*)__Instance)->height;
            }

            set
            {
                ((__Internal*)__Instance)->height = value;
            }
        }

        /// <summary>Horizontal pixel position of the cursor hotspot within the image.</summary>
        public ushort HotX
        {
            get
            {
                return ((__Internal*)__Instance)->hotX;
            }

            set
            {
                ((__Internal*)__Instance)->hotX = value;
            }
        }

        /// <summary>Vertical pixel position of the cursor hotspot within the image.</summary>
        public ushort HotY
        {
            get
            {
                return ((__Internal*)__Instance)->hotY;
            }

            set
            {
                ((__Internal*)__Instance)->hotY = value;
            }
        }

        /// <summary>`true` if the cursor mode should be updated. The `relative`, `positionX`, and `positionY` members are valid.</summary>
        public bool ModeUpdate
        {
            get
            {
                return ((__Internal*)__Instance)->modeUpdate != 0;
            }

            set
            {
                ((__Internal*)__Instance)->modeUpdate = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the cursor image should be updated. The `width`, `height`, `hotX`, `hotY`, and `size` members are valid.</summary>
        public bool ImageUpdate
        {
            get
            {
                return ((__Internal*)__Instance)->imageUpdate != 0;
            }

            set
            {
                ((__Internal*)__Instance)->imageUpdate = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if in relative mode, meaning the client should submit mouse motion in relative distances rather than absolute screen coordinates.</summary>
        public bool Relative
        {
            get
            {
                return ((__Internal*)__Instance)->relative != 0;
            }

            set
            {
                ((__Internal*)__Instance)->relative = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Guest input permissions.</summary>
    /// <remarks>Member of ::ParsecGuest and passed to ::ParsecHostSetPermissions. Only relevant in ::HOST_DESKTOP.</remarks>
    public unsafe partial class Permissions : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal byte gamepad;
            internal byte keyboard;
            internal byte mouse;
            internal fixed byte __pad[1];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecPermissions@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Permissions> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Permissions>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Permissions managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Permissions managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Permissions __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Permissions(native.ToPointer(), skipVTables);
        }

        internal static Permissions __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Permissions)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Permissions __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Permissions(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Permissions(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Permissions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Permissions()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Permissions.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Permissions(global::ParsecSharp.Permissions _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Permissions.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Permissions.__Internal*) __Instance) = *((global::ParsecSharp.Permissions.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The guest can send gamepad input.</summary>
        public bool Gamepad
        {
            get
            {
                return ((__Internal*)__Instance)->gamepad != 0;
            }

            set
            {
                ((__Internal*)__Instance)->gamepad = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>The guest can send keyboard input.</summary>
        public bool Keyboard
        {
            get
            {
                return ((__Internal*)__Instance)->keyboard != 0;
            }

            set
            {
                ((__Internal*)__Instance)->keyboard = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>The guest can send mouse button.</summary>
        public bool Mouse
        {
            get
            {
                return ((__Internal*)__Instance)->mouse != 0;
            }

            set
            {
                ((__Internal*)__Instance)->mouse = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Latency performance metrics.</summary>
    /// <remarks>Member of ::ParsecGuest and ::ParsecClientStatus.</remarks>
    public unsafe partial class Metrics : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal float encodeLatency;
            internal float decodeLatency;
            internal float networkLatency;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecMetrics@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Metrics> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Metrics>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Metrics managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Metrics managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Metrics __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Metrics(native.ToPointer(), skipVTables);
        }

        internal static Metrics __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Metrics)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Metrics __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Metrics(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Metrics(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Metrics(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Metrics()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Metrics.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Metrics(global::ParsecSharp.Metrics _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Metrics.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Metrics.__Internal*) __Instance) = *((global::ParsecSharp.Metrics.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Average time in milliseconds for the host to encode a frame.</summary>
        public float EncodeLatency
        {
            get
            {
                return ((__Internal*)__Instance)->encodeLatency;
            }

            set
            {
                ((__Internal*)__Instance)->encodeLatency = value;
            }
        }

        /// <summary>Average time in milliseconds for the client to decode a frame.</summary>
        public float DecodeLatency
        {
            get
            {
                return ((__Internal*)__Instance)->decodeLatency;
            }

            set
            {
                ((__Internal*)__Instance)->decodeLatency = value;
            }
        }

        /// <summary>Average round trip time between the client and host.</summary>
        public float NetworkLatency
        {
            get
            {
                return ((__Internal*)__Instance)->networkLatency;
            }

            set
            {
                ((__Internal*)__Instance)->networkLatency = value;
            }
        }
    }

    /// <summary>Guest properties.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecGuestStateChangeEvent and ::ParsecUserDataEvent. Returned by ::ParsecHostGetGuests</para>
    /// <para>and ::ParsecHostPollInput.</para>
    /// </remarks>
    public unsafe partial class Guest : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 408)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Permissions.__Internal perms;
            internal global::ParsecSharp.Metrics.__Internal metrics;
            internal global::ParsecSharp.GuestState state;
            internal uint id;
            internal uint userID;
            internal fixed sbyte name[320];
            internal fixed sbyte attemptID[56];
            internal byte owner;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecGuest@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Guest> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Guest>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Guest managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Guest managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Guest __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Guest(native.ToPointer(), skipVTables);
        }

        internal static Guest __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Guest)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Guest __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Guest(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Guest(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Guest(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Guest()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Guest.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Guest(global::ParsecSharp.Guest _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Guest.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Guest.__Internal*) __Instance) = *((global::ParsecSharp.Guest.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Guest input permissions. ::HOST_DESKTOP only.</summary>
        public global::ParsecSharp.Permissions Perms
        {
            get
            {
                return global::ParsecSharp.Permissions.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->perms));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->perms = *(global::ParsecSharp.Permissions.__Internal*) value.__Instance;
            }
        }

        /// <summary>Latency performance metrics, only valid in state ::GUEST_CONNECTED.</summary>
        public global::ParsecSharp.Metrics Metrics
        {
            get
            {
                return global::ParsecSharp.Metrics.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->metrics));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->metrics = *(global::ParsecSharp.Metrics.__Internal*) value.__Instance;
            }
        }

        /// <summary>Guest connection lifecycle states.</summary>
        public global::ParsecSharp.GuestState State
        {
            get
            {
                return ((__Internal*)__Instance)->state;
            }

            set
            {
                ((__Internal*)__Instance)->state = value;
            }
        }

        /// <summary>Guest ID passed to various host functions.</summary>
        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>Parsec unique user ID.</summary>
        public uint UserID
        {
            get
            {
                return ((__Internal*)__Instance)->userID;
            }

            set
            {
                ((__Internal*)__Instance)->userID = value;
            }
        }

        /// <summary>UTF-8 null-terminated name guest name string.</summary>
        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 320);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 320; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        /// <summary>Unique connection ID valid while `state` is ::GUEST_WAITING, otherwise filled with zeroes. ::HOST_DESKTOP only.</summary>
        public sbyte[] AttemptID
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->attemptID, 56);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 56; i++)
                        ((__Internal*)__Instance)->attemptID[i] = value[i];
                }
            }
        }

        /// <summary>The guest is also the owner of the host computer. ::HOST_DESKTOP only.</summary>
        public bool Owner
        {
            get
            {
                return ((__Internal*)__Instance)->owner != 0;
            }

            set
            {
                ((__Internal*)__Instance)->owner = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Keyboard message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial class KeyboardMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Keycode code;
            internal global::ParsecSharp.Keymod mod;
            internal byte pressed;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecKeyboardMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.KeyboardMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.KeyboardMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.KeyboardMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.KeyboardMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static KeyboardMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new KeyboardMessage(native.ToPointer(), skipVTables);
        }

        internal static KeyboardMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (KeyboardMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static KeyboardMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new KeyboardMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private KeyboardMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected KeyboardMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public KeyboardMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.KeyboardMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public KeyboardMessage(global::ParsecSharp.KeyboardMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.KeyboardMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.KeyboardMessage.__Internal*) __Instance) = *((global::ParsecSharp.KeyboardMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Keyboard input.</summary>
        public global::ParsecSharp.Keycode Code
        {
            get
            {
                return ((__Internal*)__Instance)->code;
            }

            set
            {
                ((__Internal*)__Instance)->code = value;
            }
        }

        /// <summary>Stateful modifier keys applied to keyboard input.</summary>
        public global::ParsecSharp.Keymod Mod
        {
            get
            {
                return ((__Internal*)__Instance)->mod;
            }

            set
            {
                ((__Internal*)__Instance)->mod = value;
            }
        }

        /// <summary>`true` if pressed, `false` if released.</summary>
        public bool Pressed
        {
            get
            {
                return ((__Internal*)__Instance)->pressed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->pressed = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Mouse button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial class MouseButtonMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.MouseButton button;
            internal byte pressed;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecMouseButtonMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.MouseButtonMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.MouseButtonMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.MouseButtonMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.MouseButtonMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MouseButtonMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MouseButtonMessage(native.ToPointer(), skipVTables);
        }

        internal static MouseButtonMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MouseButtonMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MouseButtonMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseButtonMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MouseButtonMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MouseButtonMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MouseButtonMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.MouseButtonMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public MouseButtonMessage(global::ParsecSharp.MouseButtonMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.MouseButtonMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.MouseButtonMessage.__Internal*) __Instance) = *((global::ParsecSharp.MouseButtonMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Mouse button.</summary>
        public global::ParsecSharp.MouseButton Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>`true` if clicked, `false` if released.</summary>
        public bool Pressed
        {
            get
            {
                return ((__Internal*)__Instance)->pressed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->pressed = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Mouse wheel message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial class MouseWheelMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecMouseWheelMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.MouseWheelMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.MouseWheelMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.MouseWheelMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.MouseWheelMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MouseWheelMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MouseWheelMessage(native.ToPointer(), skipVTables);
        }

        internal static MouseWheelMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MouseWheelMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MouseWheelMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseWheelMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MouseWheelMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MouseWheelMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MouseWheelMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.MouseWheelMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public MouseWheelMessage(global::ParsecSharp.MouseWheelMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.MouseWheelMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.MouseWheelMessage.__Internal*) __Instance) = *((global::ParsecSharp.MouseWheelMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Horizontal delta of mouse wheel rotation. Negative values scroll left.</summary>
        public int X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>Vertical delta of mouse wheel rotation. Negative values scroll up.</summary>
        public int Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    /// <summary>Mouse motion message.</summary>
    /// <remarks>
    /// <para>Member of ::ParsecMessage. Mouse motion can be sent in either relative or absolute mode via</para>
    /// <para>the `relative` member. Absolute mode treats the `x` and `y` values as the exact destination for where</para>
    /// <para>the cursor will appear. These values are sent from the client in device screen coordinates and are translated</para>
    /// <para>in accordance with the values set via ::ParsecClientSetDimensions. Relative mode `x` and `y` values are not</para>
    /// <para>affected by ::ParsecClientSetDimensions and move the cursor with a signed delta value from its previous location.</para>
    /// </remarks>
    public unsafe partial class MouseMotionMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int x;
            internal int y;
            internal byte relative;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecMouseMotionMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.MouseMotionMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.MouseMotionMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.MouseMotionMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.MouseMotionMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static MouseMotionMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new MouseMotionMessage(native.ToPointer(), skipVTables);
        }

        internal static MouseMotionMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (MouseMotionMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static MouseMotionMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MouseMotionMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MouseMotionMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected MouseMotionMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MouseMotionMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.MouseMotionMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public MouseMotionMessage(global::ParsecSharp.MouseMotionMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.MouseMotionMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.MouseMotionMessage.__Internal*) __Instance) = *((global::ParsecSharp.MouseMotionMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The absolute horizontal screen coordinate of the cursor  if `relative` is `false`, or the delta (can be negative) if `relative` is `true`.</summary>
        public int X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>The absolute vertical screen coordinate of the cursor if `relative` is `false`, or the delta (can be negative) if `relative` is `true`.</summary>
        public int Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>`true` for relative mode, `false` for absolute mode. See above.</summary>
        public bool Relative
        {
            get
            {
                return ((__Internal*)__Instance)->relative != 0;
            }

            set
            {
                ((__Internal*)__Instance)->relative = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Gamepad button message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial class GamepadButtonMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.GamepadButton button;
            internal uint id;
            internal byte pressed;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecGamepadButtonMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GamepadButtonMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GamepadButtonMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.GamepadButtonMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.GamepadButtonMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadButtonMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadButtonMessage(native.ToPointer(), skipVTables);
        }

        internal static GamepadButtonMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadButtonMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadButtonMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadButtonMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadButtonMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadButtonMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadButtonMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GamepadButtonMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadButtonMessage(global::ParsecSharp.GamepadButtonMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GamepadButtonMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.GamepadButtonMessage.__Internal*) __Instance) = *((global::ParsecSharp.GamepadButtonMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gamepad button.</summary>
        public global::ParsecSharp.GamepadButton Button
        {
            get
            {
                return ((__Internal*)__Instance)->button;
            }

            set
            {
                ((__Internal*)__Instance)->button = value;
            }
        }

        /// <summary>Unique client-provided index identifying the gamepad.</summary>
        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>`true` if the button was pressed, `false` if released.</summary>
        public bool Pressed
        {
            get
            {
                return ((__Internal*)__Instance)->pressed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->pressed = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Gamepad axis message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial class GamepadAxisMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.GamepadAxis axis;
            internal uint id;
            internal short value;
            internal fixed byte __pad[2];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecGamepadAxisMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GamepadAxisMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GamepadAxisMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.GamepadAxisMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.GamepadAxisMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadAxisMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadAxisMessage(native.ToPointer(), skipVTables);
        }

        internal static GamepadAxisMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadAxisMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadAxisMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadAxisMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadAxisMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadAxisMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadAxisMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GamepadAxisMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadAxisMessage(global::ParsecSharp.GamepadAxisMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GamepadAxisMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.GamepadAxisMessage.__Internal*) __Instance) = *((global::ParsecSharp.GamepadAxisMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Gamepad axes related to thumbsticks and triggers.</summary>
        public global::ParsecSharp.GamepadAxis Axis
        {
            get
            {
                return ((__Internal*)__Instance)->axis;
            }

            set
            {
                ((__Internal*)__Instance)->axis = value;
            }
        }

        /// <summary>Unique client-provided index identifying the gamepad.</summary>
        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>The new value of the axis between -32,768 (left/down) and 32,767 (right/up).</summary>
        public short Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Gamepad unplug message.</summary>
    /// <remarks>Member of ::ParsecMessage.</remarks>
    public unsafe partial class GamepadUnplugMessage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            internal uint id;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecGamepadUnplugMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GamepadUnplugMessage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GamepadUnplugMessage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.GamepadUnplugMessage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.GamepadUnplugMessage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GamepadUnplugMessage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GamepadUnplugMessage(native.ToPointer(), skipVTables);
        }

        internal static GamepadUnplugMessage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GamepadUnplugMessage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GamepadUnplugMessage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GamepadUnplugMessage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GamepadUnplugMessage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GamepadUnplugMessage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GamepadUnplugMessage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GamepadUnplugMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GamepadUnplugMessage(global::ParsecSharp.GamepadUnplugMessage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GamepadUnplugMessage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.GamepadUnplugMessage.__Internal*) __Instance) = *((global::ParsecSharp.GamepadUnplugMessage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Unique client-provided index identifying the gamepad.</summary>
        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }
    }

    /// <summary>Generic input message that can represent any message type.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientSendMessage or returned by ::ParsecHostPollInput while</para>
    /// <para>in ::HOST_GAME. The application can switch on the `type` member to see which `Message`</para>
    /// <para>struct should be evaluated. The `Message` structs are unioned.</para>
    /// </remarks>
    public unsafe partial class Message : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ParsecSharp.MessageType type;

            [FieldOffset(4)]
            internal global::ParsecSharp.KeyboardMessage.__Internal keyboard;

            [FieldOffset(4)]
            internal global::ParsecSharp.MouseButtonMessage.__Internal mouseButton;

            [FieldOffset(4)]
            internal global::ParsecSharp.MouseWheelMessage.__Internal mouseWheel;

            [FieldOffset(4)]
            internal global::ParsecSharp.MouseMotionMessage.__Internal mouseMotion;

            [FieldOffset(4)]
            internal global::ParsecSharp.GamepadButtonMessage.__Internal gamepadButton;

            [FieldOffset(4)]
            internal global::ParsecSharp.GamepadAxisMessage.__Internal gamepadAxis;

            [FieldOffset(4)]
            internal global::ParsecSharp.GamepadUnplugMessage.__Internal gamepadUnplug;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecMessage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Message> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.Message>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.Message managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.Message managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Message __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Message(native.ToPointer(), skipVTables);
        }

        internal static Message __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Message)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Message __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Message(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Message(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Message(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Message()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Message.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Message(global::ParsecSharp.Message _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.Message.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.Message.__Internal*) __Instance) = *((global::ParsecSharp.Message.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Input message type.</summary>
        public global::ParsecSharp.MessageType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Keyboard message.</summary>
        public global::ParsecSharp.KeyboardMessage Keyboard
        {
            get
            {
                return global::ParsecSharp.KeyboardMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->keyboard));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->keyboard = *(global::ParsecSharp.KeyboardMessage.__Internal*) value.__Instance;
            }
        }

        /// <summary>Mouse button message.</summary>
        public global::ParsecSharp.MouseButtonMessage MouseButton
        {
            get
            {
                return global::ParsecSharp.MouseButtonMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mouseButton));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mouseButton = *(global::ParsecSharp.MouseButtonMessage.__Internal*) value.__Instance;
            }
        }

        /// <summary>Mouse wheel message.</summary>
        public global::ParsecSharp.MouseWheelMessage MouseWheel
        {
            get
            {
                return global::ParsecSharp.MouseWheelMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mouseWheel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mouseWheel = *(global::ParsecSharp.MouseWheelMessage.__Internal*) value.__Instance;
            }
        }

        /// <summary>Mouse motion message.</summary>
        public global::ParsecSharp.MouseMotionMessage MouseMotion
        {
            get
            {
                return global::ParsecSharp.MouseMotionMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->mouseMotion));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->mouseMotion = *(global::ParsecSharp.MouseMotionMessage.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad button message.</summary>
        public global::ParsecSharp.GamepadButtonMessage GamepadButton
        {
            get
            {
                return global::ParsecSharp.GamepadButtonMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gamepadButton));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gamepadButton = *(global::ParsecSharp.GamepadButtonMessage.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad axis message.</summary>
        public global::ParsecSharp.GamepadAxisMessage GamepadAxis
        {
            get
            {
                return global::ParsecSharp.GamepadAxisMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gamepadAxis));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gamepadAxis = *(global::ParsecSharp.GamepadAxisMessage.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad unplug message.</summary>
        public global::ParsecSharp.GamepadUnplugMessage GamepadUnplug
        {
            get
            {
                return global::ParsecSharp.GamepadUnplugMessage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gamepadUnplug));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gamepadUnplug = *(global::ParsecSharp.GamepadUnplugMessage.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Client configuration.</summary>
    /// <remarks>
    /// <para>Passed to ::ParsecClientConnect. Regarding `resolutionX`, `resolutionY`, and `refreshRate`:</para>
    /// <para>These settings apply only in ::HOST_DESKTOP if the client is the first client to connect, and that client is</para>
    /// <para>the owner of the computer. Setting `resolutionX` or `resolutionY` to `0` will leave the host resolution unaffected,</para>
    /// <para>otherwise the host will attempt to find the closest matching resolution / refresh rate.</para>
    /// </remarks>
    public unsafe partial class ClientConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int decoderSoftware;
            internal int mediaContainer;
            internal int protocol;
            internal int resolutionX;
            internal int resolutionY;
            internal int refreshRate;
            internal byte pngCursor;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecClientConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.ClientConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.ClientConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClientConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClientConfig(native.ToPointer(), skipVTables);
        }

        internal static ClientConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClientConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClientConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClientConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClientConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClientConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClientConfig(global::ParsecSharp.ClientConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.ClientConfig.__Internal*) __Instance) = *((global::ParsecSharp.ClientConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>`true` to force decoding of video frames via a software implementation.</summary>
        public int DecoderSoftware
        {
            get
            {
                return ((__Internal*)__Instance)->decoderSoftware;
            }

            set
            {
                ((__Internal*)__Instance)->decoderSoftware = value;
            }
        }

        /// <summary>::ParsecContainer value.</summary>
        public int MediaContainer
        {
            get
            {
                return ((__Internal*)__Instance)->mediaContainer;
            }

            set
            {
                ((__Internal*)__Instance)->mediaContainer = value;
            }
        }

        /// <summary>::ParsecProtocol value.</summary>
        public int Protocol
        {
            get
            {
                return ((__Internal*)__Instance)->protocol;
            }

            set
            {
                ((__Internal*)__Instance)->protocol = value;
            }
        }

        /// <summary>See above.</summary>
        public int ResolutionX
        {
            get
            {
                return ((__Internal*)__Instance)->resolutionX;
            }

            set
            {
                ((__Internal*)__Instance)->resolutionX = value;
            }
        }

        /// <summary>See above.</summary>
        public int ResolutionY
        {
            get
            {
                return ((__Internal*)__Instance)->resolutionY;
            }

            set
            {
                ((__Internal*)__Instance)->resolutionY = value;
            }
        }

        /// <summary>See above.</summary>
        public int RefreshRate
        {
            get
            {
                return ((__Internal*)__Instance)->refreshRate;
            }

            set
            {
                ((__Internal*)__Instance)->refreshRate = value;
            }
        }

        /// <summary>`true` to return compressed PNG cursor images during ::ParsecClientPollEvents, `false` to return a 32-bit RGBA image.</summary>
        public bool PngCursor
        {
            get
            {
                return ((__Internal*)__Instance)->pngCursor != 0;
            }

            set
            {
                ((__Internal*)__Instance)->pngCursor = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Client connection health and status information.</summary>
    /// <remarks>Returned by ::ParsecClientGetStatus.</remarks>
    public unsafe partial class ClientStatus : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Metrics.__Internal metrics;
            internal fixed sbyte attemptID[56];
            internal byte networkFailure;
            internal byte decoderFallback;
            internal fixed byte __pad[1];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecClientStatus@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientStatus> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientStatus>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.ClientStatus managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.ClientStatus managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClientStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClientStatus(native.ToPointer(), skipVTables);
        }

        internal static ClientStatus __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClientStatus)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClientStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientStatus(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClientStatus(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClientStatus(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClientStatus()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientStatus.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClientStatus(global::ParsecSharp.ClientStatus _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientStatus.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.ClientStatus.__Internal*) __Instance) = *((global::ParsecSharp.ClientStatus.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Latency performance metrics.</summary>
        public global::ParsecSharp.Metrics Metrics
        {
            get
            {
                return global::ParsecSharp.Metrics.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->metrics));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->metrics = *(global::ParsecSharp.Metrics.__Internal*) value.__Instance;
            }
        }

        /// <summary>Most recent connection `attemptID`. Valid even if ::ParsecClientConnect does not return ::PARSEC_OK.</summary>
        public sbyte[] AttemptID
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->attemptID, 56);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 56; i++)
                        ((__Internal*)__Instance)->attemptID[i] = value[i];
                }
            }
        }

        /// <summary>Client is currently experiencing network failure.</summary>
        public bool NetworkFailure
        {
            get
            {
                return ((__Internal*)__Instance)->networkFailure != 0;
            }

            set
            {
                ((__Internal*)__Instance)->networkFailure = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the client had to fallback to software decoding after being unable to internally initialize a hardware accelerated decoder.</summary>
        public bool DecoderFallback
        {
            get
            {
                return ((__Internal*)__Instance)->decoderFallback != 0;
            }

            set
            {
                ((__Internal*)__Instance)->decoderFallback = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Cursor mode/image update event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public unsafe partial class ClientCursorEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Cursor.__Internal cursor;
            internal uint key;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecClientCursorEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientCursorEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientCursorEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.ClientCursorEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.ClientCursorEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClientCursorEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClientCursorEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientCursorEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClientCursorEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClientCursorEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientCursorEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClientCursorEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClientCursorEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClientCursorEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientCursorEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClientCursorEvent(global::ParsecSharp.ClientCursorEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientCursorEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.ClientCursorEvent.__Internal*) __Instance) = *((global::ParsecSharp.ClientCursorEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Cursor properties.</summary>
        public global::ParsecSharp.Cursor Cursor
        {
            get
            {
                return global::ParsecSharp.Cursor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cursor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cursor = *(global::ParsecSharp.Cursor.__Internal*) value.__Instance;
            }
        }

        /// <summary>Buffer lookup key passed to ::ParsecGetBuffer to retrieve the cursor image, if available.</summary>
        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }
    }

    /// <summary>Gamepad rumble data event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public unsafe partial class ClientRumbleEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint gamepadID;
            internal byte motorBig;
            internal byte motorSmall;
            internal fixed byte __pad[2];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecClientRumbleEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientRumbleEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientRumbleEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.ClientRumbleEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.ClientRumbleEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClientRumbleEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClientRumbleEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientRumbleEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClientRumbleEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClientRumbleEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientRumbleEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClientRumbleEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClientRumbleEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClientRumbleEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientRumbleEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClientRumbleEvent(global::ParsecSharp.ClientRumbleEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientRumbleEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.ClientRumbleEvent.__Internal*) __Instance) = *((global::ParsecSharp.ClientRumbleEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Unique client-assigned index identifying the gamepad connected to the client.</summary>
        public uint GamepadID
        {
            get
            {
                return ((__Internal*)__Instance)->gamepadID;
            }

            set
            {
                ((__Internal*)__Instance)->gamepadID = value;
            }
        }

        /// <summary>8-bit unsigned value for large motor vibration.</summary>
        public byte MotorBig
        {
            get
            {
                return ((__Internal*)__Instance)->motorBig;
            }

            set
            {
                ((__Internal*)__Instance)->motorBig = value;
            }
        }

        /// <summary>8-bit unsigned value for small motor vibration.</summary>
        public byte MotorSmall
        {
            get
            {
                return ((__Internal*)__Instance)->motorSmall;
            }

            set
            {
                ((__Internal*)__Instance)->motorSmall = value;
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>User-defined host message event.</summary>
    /// <remarks>Member of ::ParsecClientEvent.</remarks>
    public unsafe partial class ClientUserDataEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint id;
            internal uint key;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecClientUserDataEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientUserDataEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientUserDataEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.ClientUserDataEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.ClientUserDataEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClientUserDataEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClientUserDataEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientUserDataEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClientUserDataEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClientUserDataEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientUserDataEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClientUserDataEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClientUserDataEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClientUserDataEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientUserDataEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClientUserDataEvent(global::ParsecSharp.ClientUserDataEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientUserDataEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.ClientUserDataEvent.__Internal*) __Instance) = *((global::ParsecSharp.ClientUserDataEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>User-defined message ID set by the host.</summary>
        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>Buffer lookup key passed to ::ParsecGetBuffer to retrieve the message.</summary>
        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }
    }

    /// <summary>Generic client event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecClientPollEvents. The application can switch on the `type` member to see</para>
    /// <para>which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    public unsafe partial class ClientEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 32)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ParsecSharp.ClientEventType type;

            [FieldOffset(4)]
            internal global::ParsecSharp.ClientCursorEvent.__Internal cursor;

            [FieldOffset(4)]
            internal global::ParsecSharp.ClientRumbleEvent.__Internal rumble;

            [FieldOffset(4)]
            internal global::ParsecSharp.ClientUserDataEvent.__Internal userData;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecClientEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.ClientEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.ClientEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.ClientEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ClientEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ClientEvent(native.ToPointer(), skipVTables);
        }

        internal static ClientEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ClientEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ClientEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ClientEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ClientEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ClientEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ClientEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ClientEvent(global::ParsecSharp.ClientEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.ClientEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.ClientEvent.__Internal*) __Instance) = *((global::ParsecSharp.ClientEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Client event type.</summary>
        public global::ParsecSharp.ClientEventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Cursor mode/image update event.</summary>
        public global::ParsecSharp.ClientCursorEvent Cursor
        {
            get
            {
                return global::ParsecSharp.ClientCursorEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cursor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cursor = *(global::ParsecSharp.ClientCursorEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>Gamepad rumble data event.</summary>
        public global::ParsecSharp.ClientRumbleEvent Rumble
        {
            get
            {
                return global::ParsecSharp.ClientRumbleEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rumble));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rumble = *(global::ParsecSharp.ClientRumbleEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>User-defined host message event.</summary>
        public global::ParsecSharp.ClientUserDataEvent UserData
        {
            get
            {
                return global::ParsecSharp.ClientUserDataEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->userData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->userData = *(global::ParsecSharp.ClientUserDataEvent.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>Host configuration.</summary>
    /// <remarks>Member of ::ParsecHostStatus, passed to ::ParsecHostStart and ::ParsecHostSetConfig.</remarks>
    public unsafe partial class HostConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 880)]
        public partial struct __Internal
        {
            internal int resolutionX;
            internal int resolutionY;
            internal int refreshRate;
            internal int adminMute;
            internal int exclusiveInput;
            internal int encoderFPS;
            internal int encoderMaxBitrate;
            internal int encoderH265;
            internal int maxGuests;
            internal fixed sbyte name[256];
            internal fixed sbyte desc[512];
            internal fixed sbyte gameID[72];
            internal byte publicGame;
            internal fixed byte __pad[3];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecHostConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.HostConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.HostConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.HostConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.HostConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HostConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HostConfig(native.ToPointer(), skipVTables);
        }

        internal static HostConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HostConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HostConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HostConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HostConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HostConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HostConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.HostConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HostConfig(global::ParsecSharp.HostConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.HostConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.HostConfig.__Internal*) __Instance) = *((global::ParsecSharp.HostConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Resolution width. ::HOST_DESKTOP owner only.</summary>
        public int ResolutionX
        {
            get
            {
                return ((__Internal*)__Instance)->resolutionX;
            }

            set
            {
                ((__Internal*)__Instance)->resolutionX = value;
            }
        }

        /// <summary>Resolution height. ::HOST_DESKTOP owner only.</summary>
        public int ResolutionY
        {
            get
            {
                return ((__Internal*)__Instance)->resolutionY;
            }

            set
            {
                ((__Internal*)__Instance)->resolutionY = value;
            }
        }

        /// <summary>Refresh rate in Hz. ::HOST_DESKTOP owner only.</summary>
        public int RefreshRate
        {
            get
            {
                return ((__Internal*)__Instance)->refreshRate;
            }

            set
            {
                ((__Internal*)__Instance)->refreshRate = value;
            }
        }

        /// <summary>Mute local audio on owner connection. ::HOST_DESKTOP owner only.</summary>
        public int AdminMute
        {
            get
            {
                return ((__Internal*)__Instance)->adminMute;
            }

            set
            {
                ((__Internal*)__Instance)->adminMute = value;
            }
        }

        /// <summary>Block remote input when local host input occurs. ::HOST_DESKTOP only.</summary>
        public int ExclusiveInput
        {
            get
            {
                return ((__Internal*)__Instance)->exclusiveInput;
            }

            set
            {
                ((__Internal*)__Instance)->exclusiveInput = value;
            }
        }

        /// <summary>Desired frames per second.</summary>
        public int EncoderFPS
        {
            get
            {
                return ((__Internal*)__Instance)->encoderFPS;
            }

            set
            {
                ((__Internal*)__Instance)->encoderFPS = value;
            }
        }

        /// <summary>Maximum output bitrate in Mbps, split between guests.</summary>
        public int EncoderMaxBitrate
        {
            get
            {
                return ((__Internal*)__Instance)->encoderMaxBitrate;
            }

            set
            {
                ((__Internal*)__Instance)->encoderMaxBitrate = value;
            }
        }

        /// <summary>Allow H.265 codec.</summary>
        public int EncoderH265
        {
            get
            {
                return ((__Internal*)__Instance)->encoderH265;
            }

            set
            {
                ((__Internal*)__Instance)->encoderH265 = value;
            }
        }

        /// <summary>Total number of guests allowed at once. This number should not include the local host.</summary>
        public int MaxGuests
        {
            get
            {
                return ((__Internal*)__Instance)->maxGuests;
            }

            set
            {
                ((__Internal*)__Instance)->maxGuests = value;
            }
        }

        /// <summary>UTF-8 null-terminated name string. May be zeroed to use hostname.</summary>
        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->name[i] = value[i];
                }
            }
        }

        /// <summary>UTF-8 null-terminated description string. ::HOST_GAME only.</summary>
        public sbyte[] Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->desc, 512);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 512; i++)
                        ((__Internal*)__Instance)->desc[i] = value[i];
                }
            }
        }

        /// <summary>Game unique identifier issued by Parsec. ::HOST_GAME only.</summary>
        public sbyte[] GameID
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->gameID, 72);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 72; i++)
                        ((__Internal*)__Instance)->gameID[i] = value[i];
                }
            }
        }

        /// <summary>Set to `true` to allow the hosting session to be visible publicly in the Parsec Arcade. ::HOST_GAME only.</summary>
        public bool PublicGame
        {
            get
            {
                return ((__Internal*)__Instance)->publicGame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->publicGame = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Host runtime status.</summary>
    /// <remarks>Returned by ::ParsecHostGetStatus.</remarks>
    public unsafe partial class HostStatus : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 888)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.HostConfig.__Internal cfg;
            internal uint numGuests;
            internal byte running;
            internal byte invalidSessionID;
            internal byte gamepadSupport;
            internal fixed byte __pad[1];

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecHostStatus@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.HostStatus> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.HostStatus>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.HostStatus managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.HostStatus managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HostStatus __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HostStatus(native.ToPointer(), skipVTables);
        }

        internal static HostStatus __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HostStatus)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HostStatus __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HostStatus(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HostStatus(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HostStatus(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HostStatus()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.HostStatus.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HostStatus(global::ParsecSharp.HostStatus _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.HostStatus.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.HostStatus.__Internal*) __Instance) = *((global::ParsecSharp.HostStatus.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The currently active host configuration.</summary>
        public global::ParsecSharp.HostConfig Cfg
        {
            get
            {
                return global::ParsecSharp.HostConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->cfg));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->cfg = *(global::ParsecSharp.HostConfig.__Internal*) value.__Instance;
            }
        }

        /// <summary>The number of guests currently in state ::GUEST_CONNECTED.</summary>
        public uint NumGuests
        {
            get
            {
                return ((__Internal*)__Instance)->numGuests;
            }

            set
            {
                ((__Internal*)__Instance)->numGuests = value;
            }
        }

        /// <summary>The host is currently accepting guests after calling ::ParsecHostStart.</summary>
        public bool Running
        {
            get
            {
                return ((__Internal*)__Instance)->running != 0;
            }

            set
            {
                ((__Internal*)__Instance)->running = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the host's Session ID has become invalid. The host must call ::ParsecHostSetConfig with a valid `sessionID` to continue hosting.</summary>
        public bool InvalidSessionID
        {
            get
            {
                return ((__Internal*)__Instance)->invalidSessionID != 0;
            }

            set
            {
                ((__Internal*)__Instance)->invalidSessionID = (byte) (value ? 1 : 0);
            }
        }

        /// <summary>`true` if the virtual gamepad driver is working properly, otherwise `false`. ::HOST_DESKTOP only.</summary>
        public bool GamepadSupport
        {
            get
            {
                return ((__Internal*)__Instance)->gamepadSupport != 0;
            }

            set
            {
                ((__Internal*)__Instance)->gamepadSupport = (byte) (value ? 1 : 0);
            }
        }

        public byte[] Pad
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->__pad, 1);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 1; i++)
                        ((__Internal*)__Instance)->__pad[i] = value[i];
                }
            }
        }
    }

    /// <summary>Guest connection state change event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    public unsafe partial class GuestStateChangeEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 408)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Guest.__Internal guest;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecGuestStateChangeEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GuestStateChangeEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.GuestStateChangeEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.GuestStateChangeEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.GuestStateChangeEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GuestStateChangeEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new GuestStateChangeEvent(native.ToPointer(), skipVTables);
        }

        internal static GuestStateChangeEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GuestStateChangeEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GuestStateChangeEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GuestStateChangeEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GuestStateChangeEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected GuestStateChangeEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public GuestStateChangeEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GuestStateChangeEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GuestStateChangeEvent(global::ParsecSharp.GuestStateChangeEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.GuestStateChangeEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.GuestStateChangeEvent.__Internal*) __Instance) = *((global::ParsecSharp.GuestStateChangeEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Guest properties. The `state` member can be used to evaluate the guest's state change.</summary>
        public global::ParsecSharp.Guest Guest
        {
            get
            {
                return global::ParsecSharp.Guest.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->guest));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->guest = *(global::ParsecSharp.Guest.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>User-defined guest message event.</summary>
    /// <remarks>Member of ::ParsecHostEvent.</remarks>
    public unsafe partial class UserDataEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 416)]
        public partial struct __Internal
        {
            internal global::ParsecSharp.Guest.__Internal guest;
            internal uint id;
            internal uint key;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecUserDataEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.UserDataEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.UserDataEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.UserDataEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.UserDataEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static UserDataEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new UserDataEvent(native.ToPointer(), skipVTables);
        }

        internal static UserDataEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (UserDataEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static UserDataEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new UserDataEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private UserDataEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected UserDataEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public UserDataEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.UserDataEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public UserDataEvent(global::ParsecSharp.UserDataEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.UserDataEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.UserDataEvent.__Internal*) __Instance) = *((global::ParsecSharp.UserDataEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Guest ::ParsecGuest properties.</summary>
        public global::ParsecSharp.Guest Guest
        {
            get
            {
                return global::ParsecSharp.Guest.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->guest));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->guest = *(global::ParsecSharp.Guest.__Internal*) value.__Instance;
            }
        }

        /// <summary>User-defined message ID set by the client.</summary>
        public uint Id
        {
            get
            {
                return ((__Internal*)__Instance)->id;
            }

            set
            {
                ((__Internal*)__Instance)->id = value;
            }
        }

        /// <summary>Buffer lookup key passed to ::ParsecGetBuffer to retrieve the message.</summary>
        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }
    }

    /// <summary>Generic host event that can represent any event type.</summary>
    /// <remarks>
    /// <para>Returned by ::ParsecHostPollEvents. The application can switch on the `type` member</para>
    /// <para>to see which `Event` struct should be evaluated. The `Event` structs are unioned.</para>
    /// </remarks>
    public unsafe partial class HostEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 420)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal global::ParsecSharp.HostEventType type;

            [FieldOffset(4)]
            internal global::ParsecSharp.GuestStateChangeEvent.__Internal guestStateChange;

            [FieldOffset(4)]
            internal global::ParsecSharp.UserDataEvent.__Internal userData;

            [SuppressUnmanagedCodeSecurity, DllImport("ParsecSharp", EntryPoint = "??0ParsecHostEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.HostEvent> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::ParsecSharp.HostEvent>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::ParsecSharp.HostEvent managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::ParsecSharp.HostEvent managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static HostEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new HostEvent(native.ToPointer(), skipVTables);
        }

        internal static HostEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (HostEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static HostEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new HostEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private HostEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected HostEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public HostEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.HostEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public HostEvent(global::ParsecSharp.HostEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::ParsecSharp.HostEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::ParsecSharp.HostEvent.__Internal*) __Instance) = *((global::ParsecSharp.HostEvent.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Host event type.</summary>
        public global::ParsecSharp.HostEventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->type;
            }

            set
            {
                ((__Internal*)__Instance)->type = value;
            }
        }

        /// <summary>Guest connection state change event.</summary>
        public global::ParsecSharp.GuestStateChangeEvent GuestStateChange
        {
            get
            {
                return global::ParsecSharp.GuestStateChangeEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->guestStateChange));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->guestStateChange = *(global::ParsecSharp.GuestStateChangeEvent.__Internal*) value.__Instance;
            }
        }

        /// <summary>User-defined guest message event.</summary>
        public global::ParsecSharp.UserDataEvent UserData
        {
            get
            {
                return global::ParsecSharp.UserDataEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->userData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->userData = *(global::ParsecSharp.UserDataEvent.__Internal*) value.__Instance;
            }
        }
    }
}
